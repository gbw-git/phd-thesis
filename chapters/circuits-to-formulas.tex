%!TEX root = ../main/thesis.tex
\documentclass[../main/thesis.tex]{subfiles}
\begin{document}
% We have thus far shown how to translate formulas of $\FPR$ into equivalent
% families of circuits. In this section we show how to translate families of
% circuits into equivalent formulas -- completing the proof of the main theorem
% of this paper. More explicitly, in this section we show how to construct for
% every $P$-uniform family of transparent symmetric rank-circuits a
% corresponding $\FPR$ formula defining the same query. In
% Section~\ref{sec:evaluating-circuits} we develop the theory needed for this
% construction and in Section~\ref{sec:translating-formulas-to-FPR} we use this
% theory to explicitly construct the formula.

In Chapter~\ref{chpt:formulas-to-circuits} we showed that each formula from a
fixed-point logic can be translated to a $\PT$-uniform family of transparent
symmetric circuits over the corresponding basis. In this chapter we prove the
reverse direction, showing that each $\PT$-uniform family of transparent
symmetric circuits (with a restriction on the basis) can be translated to a
formula in the fixed-point logic extended with the corresponding family of
operators. To be precise, we prove the following proposition.

\begin{prop}
  Let $\setop := \{\setop_1, \ldots, \setop_w\}$ be a set of uniform generalised
  operators that act on formulas. Let $\BB := \BB_{\setop} \cup \BB_{\std}$. Let
  $\rho$ be a relational vocabulary. For each $\PT$-uniform family of
  transparent symmetric $(\BB, \rho)$-circuits $\mathcal{C} = (C_n)_{n \in
    \nats}$ there is a formula $\theta \in \exFP{\setop}[\rho]$ such that
  $\mathcal{C}$ and $\theta$ define the same query.
  \label{prop:translate-circuits-to-formulas}
\end{prop}

% This proposition generalises Anderson and Dawar's~\cite{AndersonD17}
% translation from $\PT$-uniform families of symmetric circuits \emph{with
% majority gates} to formulas of $\FPC$. However, while the approach we take to
% prove Proposition~\ref{}bares some resemblance, Anderson and Dawar's approach
% crucially relies on the fact that the function computed by the gates in the
% circuit are symmetric. In particular, they exhibit a bijection between the
% orbit of a gate and the assignments to the support of gate, and they use this
% bijection to count the number of inputs to a gate $g$ that evaluate to true,
% which suffices to recursively evaluate $g$. Using this approach they show that
% it is possible to recursively evaluate the gates of a circuit in $\FPC$, and
% from However, in our case the gates in a circuit compute (possibly
% non-symmetric) structured functions, and so the evaluation of a gate depends
% not just


% The approach we take for proving our main result has some structuraHowever,
% Anderson and Dawar's proof uses the fact that each gate computes a symmetric
% function in order to recursively evaluate

% makes crucial use of a bijection between the orbit of a gate and its support
% in order to count the number of children of each gate that evaluate to true.
% This agrument


% of the fact that the gates in the circuit compute symmetric functions. In
% particular, Anderson and Dawar show that the g recursively evaluate the gate
% the gates in the circuit by argument uses a bijection

% However, However, Anderson and Dawar's argument makes crucial use of the fact
% at that the gates in these circuits compute symmetric functions.


% Since these circuits are defined over a symmetric basis, in their case it
% sufficed to evaluate a circuit in the logic by showing that it is possibly to
% recursively count the number of inputs to each gate that evaluate to one.
% However, in our case the gates in the circuit are labelled by structured
% functions and so the evaluation of gate depends not on the \emph{number} of
% inputs that evaluate to one but on the \emph{structure} these evaluated input
% gates define. It


% The crucial step in their proof involves defining a formula that recursively
% evaluates the gates in the circuit using a bijection between orbit and
% assignments to the support of a gate, and then using this bijection to count
% the number of inputs to a gate that evaluate to one. This approach does not
% generalise, as in our case the gates do not nessesarly compute symmetric
% functions but may compute (non-symmetric) structured functions. As such, the


% in their proof is that, using a bijection between the orbit of a gate and the
% assignments to its support, it is possible to count the number of children of
% a gate $g$ that evaluate to one by counting assignments to the supports of the
% children of $g$. This approach works precisely because the gates they are
% evaluating compute symmetric functions.




% first invoke the Immerman-Vardi theorem~\cite{Immerman198686, Vardi:1982} to
% translate the $\PT$-uniform family of circuits to an equivalent
% $\natFP$-interpretation. We show that the evaluation of a gate $g$ in a
% circuit $C_n$ for a structure $\mathcal{A}$ and bijection $\gamma \in
% [n]^{\underline{A}}$ is entirely determined by how $\gamma$ maps elements to
% the support of $g$. We use this result, along with the support theorem
% (Theorem~\ref{lem:row-column-supports}), to show that the set of bijections
% for which $g$ evaluates to true can be succinctly encoded as a set of
% assignments to the support of $g$. We use the various algorithms in
% Chapter~\ref{chpt:algorithms}, as well as numerous other constructions given
% throughout this chapter, in order to recursively construct this set of
% assignments for each gate in the circuit. Finally, we use the fixed-point
% operator to implement this recursive definition and, by evaluating the output
% gates of the circuit, we define the required formula.

% This result generalises Anderson and Dawar's~\cite{AndersonD17} translation
% from $\PT$-uniform families of symmetric circuits \emph{with majority gates}
% to formulas of $\FPC$. They prove this result by showing that the gates of a
% circuit can be recursively evaluated in $\FPC$. The crucial insight is that,
% using a bijection between the orbit of a gate and the assignments to its
% support, it is possible to count the number of children of a gate $g$ that
% evaluate to one by counting assignments to the supports of the children of
% $g$. This approach works precisely because the gates they are evaluating
% compute symmetric functions.

% The important step in their argument involves showing that there is a formula
% $\FPC$ that recursively defines the evaluation of each gate. Their


% makes use of t


% However, is it is important The important step in their argument involves
% showing that there is a formula of $\FPC$ that recursively defines the
% evaluation of each gate in the circuit. In their case, since all of the gates
% in these circuits compute symmetric functions, it suffices to determine for
% each gate the number of children of its children that evaluate to one. Their
% crucial insight is that, using a bijection between the orbit of a gate and the
% assignments to its support, they reduce the problem of counting the number of
% children of a gate $g$ that evaluate to one can be reduced to a counting
% problem on the assignments of the supports of $g$'s children. However, the
% evaluation of a gate computing a (possibly non-symmetric) structured function
% depends not just on the \emph{number} of children of $g$ that evaluate to one,
% but on the \emph{structure} defined at $g$.






% This result generalises Anderson and Dawar's~\cite{AndersonD17} translation
% from $\PT$-uniform families of symmetric circuits \emph{with majority gates}
% to formulas of $\FPC$. The important step in their argument involves showing
% that there is a formula of $\FPC$ that recursively defines the evaluation of
% each gate in the circuit. In their case, since all of the gates in these
% circuits compute symmetric functions, it suffices to determined by the number
% of children of a gate that evaluate to one. Their crucial insight is that,
% using a bijection between the orbit of a gate and the assignments to its
% support, they reduce the problem of counting the number of children of a gate
% $g$ that evaluate to one can be reduced to a counting problem on the
% assignments of the supports of $g$'s children. However, the evaluation of a
% gate computing a (possibly non-symmetric) structured function depends not just
% on the \emph{number} of children of $g$ that evaluate to one, but on the
% \emph{structure} defined at $g$.

% The c Proposition~\ref{prop:translate-circuits-to-formulas}







% They crucial observation needed to prove this result

The proof of this result is as follows. We first invoke the
Immerman-Vardi theorem~\cite{Immerman198686, Vardi:1982} to translate the
$\PT$-uniform family of circuits to an equivalent $\natFP$-interpretation. We
show that the evaluation of a gate $g$ in a circuit $C_n$ for a structure
$\mathcal{A}$ and bijection $\gamma \in [n]^{\underline{A}}$ is entirely
determined by how $\gamma$ maps elements to the support of $g$. We use this
result, along with the support theorem, to show that the set of bijections for
which $g$ evaluates to true can be succinctly encoded as a set of assignments to
the support of $g$. We use the various algorithms in
Chapter~\ref{chpt:algorithms}, as well as numerous other constructions given
throughout this chapter, in order to recursively construct for each gate $g$ the
set of assignments to the support of $g$ for which $g$ evaluates to true.
Finally, we use the fixed-point operator to implement this recursive definition
and, by evaluating the output gates of the circuit, we define the required
formula. It should be noted that the crucial step in this proof, and the one
that will be of central importance in this chapter, is the definition of a
formula that recursively evaluates each gate in the circuit for each assignment
to its support.

We should note that Proposition~\ref{prop:translate-circuits-to-formulas}
generalises Anderson and Dawar's~\cite{AndersonD17} translation from
$\PT$-uniform families of symmetric circuits \emph{with majority gates} to
formulas of $\FPC$. The crucial step in their argument similarly involves
showing that there is a formula that recursively defines the evaluation of each
gate in the circuit. They construct this formula by first exhibiting a bijection
from the orbit of a gate to the set of assignments to its support and then,
using this bijection, counting the number of children of $g$ that evaluate to
true. This argument relies on the fact that the gates in the circuit compute
symmetric functions, and so counting the number of inputs to a gate that
evaluate to true suffices to evaluate that gate. However, in this more general
setting, the gates in a circuit compute structured functions, and so the
evaluation of a gate $g$ depends not just on the \emph{number} of children that
evaluate to true, but on the \emph{structure} defined at $g$.

With this in mind, in order to recursively evaluate $g$ we first show that it is
possible to recursively define for each gate $g$ and assignment $\eta$ to the
support of $g$ a structure $M^{g, \eta}_\equiv$ isomorphic to the structure
defined at $g$. We then evaluate $g$ in the logic by applying the relevant
operator to the interpretation defining $M^{g, \eta}_{\equiv}$. 

This chapter is organised as follows. In the first section we explicitly
construct this structure for a gate and assignment to its support, and we show
that it has all of the required properties. In the second section we complete
the proof of Proposition~\ref{prop:translate-circuits-to-formulas} and, in
particular, we show that the construction given in the first section can be
implemented as an interpretation in $\natFP$.



% We should note that, while there are some broad similarities in structure
% between the proof of this result and that of Anderson and Dawar, the counting
% argument used by Anderson and present does not generalise to gates computing
% non-symmetric functions. The argument in this chapter uses a completely novel
% approach to recrusvely defi


% The vast majority of the work in this chapter is in showing how to recursively
% evaluate a gate labelled by an element of the basis corresponding to a
% generalised operator. We do so by showing that for each gate $g$ and
% assignment to its support $\eta$ we can recursively define a structure $M^{g,
% \eta}_\equiv$ isomorphic to the structure defined at $g$. This structure then
% allows us to evaluate


% In order to do so we show that for each gate $g$ and assignment to its support
% $\eta$ we can recursively define a structure $M^{g, \eta}_\equiv$ that
% determines if the bijections encoded by $\eta$ cause $g$ to evaluates to one.
% In the first section of this chapter we show how to explicitly construct this
% structure and show that it has the required properties. In the second section
% we complete proof of Proposition~\ref{prop:translate-circuits-to-formulas}
% and, in particular, we show that the construction given in the first section
% can be implemented in $\natFP$.


% d


% prove their result by showing that the circuit family is definable by an
% $\FPC$-interpretation and that the gates in the circuit can be recursively
% evaluated in $\FPC$. Their crucial insight is that, using a bijection between
% the orbit of a gate and the assignments to its support, it is possible to
% determine the number of children of a gate $g$ that evaluate to one by
% counting the


% there exists bijection between the orbit of a gate and the assignments to its
% support, and that this bijection can be used to reduce the problem of counting
% the number of children of $g$ to a counting problem on the assignments to
% supports. This insight uses the fact that the evaluation of a gate labelled by
% a symmetric function is entirely determined by the \emph{number} of input
% gates that evaluate to one. However, in this chapter we are interested in
% circuits with gates labelled by (possibly non-symmetric) structured functions.
% In this case the evaluation of a gate is determined by the \emph{structure}
% defined on the input gates. As such, while we follow a broadly similar
% approach in order to evaluate a gate in the circuit we cannot use Anderson and
% Dawar's approach in order to evaluate a gate in the circuit, and we instead
% evaluate a gate $g$ by constructing a structure isomorphic to the structure
% defined at $g$. The primary work of this chapter is in defining this
% structure, and showing that this definition can be implemented in the logic.


% The crucial insight enabling the recursive evaluation involves exhibiting a
% bijection between the orbit of a gate and the assignments to its support. They
% show that for a gate $g$ the children of $g$ can be partitioned into orbits,
% and, using the bijection, they show that the number of children in an orbit
% that evaluate to one can be determined by counting assignments to the support
% of a gate in the orbit. Then, by iterating over the orbits, they count the
% number of children of $g$ that evaluate to one, and hence evaluate $g$.
% evaluation is given by, first, exhibiting a bijection between the orbit of a
% gate and the assignments to its support and, using this bijection, they reduce
% the problem of counting the number of gates that evaluate to one in each orbit
% to a counting problem on the set of assignments to the support.

% They then show that for a gate $g$ the children of $g$ can be partitioned into
% orbits, and, using the bijection, they show that the number of children in an
% orbit that evaluate to one can be determined by counting assignments to the
% support of a gate in the orbit. Then, by iterating over the orbits, they count
% the number of children of $g$ that evaluate to one, and hence evaluate $g$.
% This approach uses the fact that the assignment to the support

% This recusive evaluation for a gate $g$ follows the children of $g$ can be
% partitioned into orbits, and, using the bijection, they show that the number
% of children in an orbit that evaluate to one can be determined by counting
% assignments to the support of a gate in the orbit. Then, by iterating over the
% orbits, they count the number of children of $g$ that evaluate to one, and
% hence evaluate $g$. The crucial insight in their argument involves exhibiting
% a bijection from the orbit of a gate to the assignments to its support. They
% use this bijection to reduce the problem of counting the number of children of
% a given gate


% is that bijection.... However, this


% They prove this result by showing that the circuit can be defined by an
% $\FPC$-interpretation and that the gates of the circuit can be recursively
% evaluated in $\FPC$. Their crucial insight is that, by exhibiting a bijection
% between the orbit of a gate and the assignments to its support, they can count
% the number of children of a particular gate $g$ in each orbit that evaluate to
% one by counting assignments. Hence they can reduce the problem of evaluting
% $g$ to a counting problem on the supports of subgates. This approach works
% preciscly because the gates are symmetric and hence their evaluation is
% determined by


% to the supports Hence they reduce the problem of evaluating a gate to the
% problem of counting the numb problem of counting the number of i


% The central insight in their proof involves exhibiting a bijection between the
% orbit of a gate and the assignments to its support. They show that for a gate
% $g$ the children of $g$ can be partitioned into orbits, and, using the
% bijection, they show that the number of children in an orbit that evaluate to
% one can be determined by counting assignments to the support of a gate in the
% orbit. Then, by iterating over the orbits, they count the number of children
% of $g$ that evaluate to one, and hence evaluate $g$. This argument allows them
% to recursively evaluate the circuit in $\FPC$, hence proving their result.

% Proposition~\ref{} generalises Anderson and Dawar's~\ref{} translation from
% $\PT$-uniform families of symmetric circuits with majority gates to $\FPC$.
% They similarly use the Immerman-Vardi theorem to translate the circuit to



% Proposition~\ref{} generalises this result, and the proof of the their result
% follows a broadly similar approach to the one used in this thesis.

% The central insight in their proof involves exhibiting a bijection between the
% orbit of a gate and the assignments to its support. They show that for a gate
% $g$ the children of $g$ can be partitioned into orbits, and, using the
% bijection, they show that the number of children in an orbit that evaluate to
% one can be determined by counting assignments to the support of a gate in the
% orbit. Then, by iterating over the orbits, they count the number of children
% of $g$ that evaluate to one, and hence evaluate $g$. This argument allows them
% to recursively evaluate the circuit in $\FPC$, hence proving their result.


% Importantly, their argument uses the fact that the evaluation of a gate
% labelled by a symmetric function is entirely determined by the \emph{number}
% of input gates that evaluate to one. However, we are interested in circuits
% with gates labelled by (possibly non-symmetric) structured functions. In this
% case the evaluation of a gate is determined by the \emph{structure} defined on
% the input gates. As such, in order to evaluate a gate in the circuit we cannot
% use Anderson and Dawar's approach in order to evaluate a gate in the circuit,
% and we instead evaluate a gate $g$ by constructing a structure isomorphic to
% the structure defined at $g$. In order to define this structure (and show that
% this structure is definable in the logic) we need substantial new developments

% The proof of Proposition~\ref{} in this chapter is outlined as follows. We
% first use the Immerman-Vardi theorem~\ref{} to translate the family of
% circuits to an equivalent interpretation. We show that the evaluation of a
% gate $g$ in a circuit $C_n$ for a structure $\mathcal{A}$ and bijection
% $\gamma \in [n]^{\underline{A}}$ depends only on how $\gamma$ maps elements to
% the support of $g$. We use this result, along with Theorem~\ref{}, to show
% that the set of bijections for which $g$ evaluates to true can be succinctly
% characterised by a set of assignments to the support of $g$. We use the
% various algorithms in Chapter~\ref{} and the Immerman-Vardi theorem, as well
% as numerous other constructions given throughout this chapter, in order to
% recursively construct this set of assignments for each gate in the circuit.
% Finally, we use the fixed-point operator to implement this recursive
% definition, and we evaluate the output gates and so define the required
% formula.


% Proposition \cite{prop:translate-circuits-to-formulas} generalises a
% translation, due to Anderson and Dawar~\cite{}, from $\PT$-uniform families of
% symmetric circuits with majority gates to formulas of $\FPC$. The proof of
% their result follows The central insight in their proof involves first
% exhibiting a bijection between the orbit of a gate and the assignments to its
% support. They then show that for a gate $g$ the children of $g$ can be
% partitioned into orbits, and, using the bijection, the number of children in
% an orbit that evaluate to one can be determined by counting assignments to the
% support of a gate in the orbit. Then, by iterating over the orbits, they count
% the number of children of $g$ that evaluate to one, and hence evaluate $g$.
% This argument allows them to show that the a gate can be recursively evaluated
% recursively evaluate the gates in the circuit in $\FPC$.

% Proposition \cite{prop:translate-circuits-to-formulas} generalises a
% translation, due to Anderson and Dawar~\cite{}, from $\PT$-uniform families of
% symmetric circuits with majority gates to formulas of $\FPC$. The central
% insight in their proof involves first exhibiting a bijection between the orbit
% of a gate and the assignments to its support. They then show that for a gate
% $g$ the children of $g$ can be partitioned into orbits, and, using the
% bijection, the number of children in an orbit that evaluate to one can be
% determined by counting assignments to the support of a gate in the orbit.
% Then, by iterating over the orbits, they count the number of children of $g$
% that evaluate to one, and hence evaluate $g$. This argument allows them to
% show that the a gate can be recursively evaluated recursively evaluate the
% gates in the circuit in $\FPC$.



% Almost all of the work in this proof is in defining the recursive formula that
% defines the set of assignments to the support of $g$ when $g$ is labelled by a
% Boolean function corresponding to a generalised operator. In order to define
% this formula we show that for any gate $g$ and assignment $\eta$ to the
% support of $g$ we can define a structure that determines the evaluation of $g$
% for $\eta$. In the first section of this chapter we construct this structure
% and prove that it suffices to determine the evaluation of the gate. In the
% second section we implement this construction in the logic and formally prove
% Proposition~\ref{prop:translate-circuits-to-formulas}.

% Proposition~\ref{} generalises a translation, due to Anderson and
% Dawar~\cite{}, from $\PT$-uniform families of symmetric circuits with majority
% gates to formulas of $\FPC$.The central insight in their proof involves first
% exhibiting a bijection between the orbit of a gate and the assignments to its
% support. They then show that for a gate $g$ the children of $g$ can be
% partitioned into orbits, and, using the bijection, the number of children in
% an orbit that evaluate to one can be determined by counting assignments to the
% support of a gate in the orbit. By iterating over orbits they can count the
% number of children of $g$ that evaluate to one, and hence evaluate $g$. This
% argument relies on the symmetry of the functions in the Boolean basis over
% which the circuit is defined, and so does not suffice in our more general
% setting. Instead, we to associate with each gate a structure, rather than a
% set of ones, that determines the evaluation of this

% Proposition~\ref{} generalises a translation, due to Anderson and
% Dawar~\cite{}, from $\PT$-uniform families of symmetric circuits with majority
% gates to formulas of $\FPC$. The first and final steps in their proof are
% similar to the steps taken

% The central insight in their proof involves first exhibiting a bijection
% between the orbit of a gate and the assignments to its support. They then show
% that for a gate $g$ the children of $g$ can be partitioned into orbits, and,
% using the bijection, the number of children in an orbit that evaluate to one
% can be determined by counting assignments to the support of a gate in the
% orbit. By iterating over orbits they can count the number of children of $g$
% that evaluate to one, and hence evaluate $g$. This argument relies on the
% symmetry of the functions in the Boolean basis over which the circuit is
% defined, and so does not suffice in our more general setting. Instead, we to
% associate with each gate a structure, rather than a set of ones, that
% determines the evaluation of this

% As such, we developed the novel, and far more sophisticated, approach outlined
% in this chapter.

% ---------------------------------------------------------------------

% In this chapter we fix a sequence of generalised operators $\setop := \{
% \setop_1, \ldots, \setop_w \}$ such that for each $\setop_i \in \setop$ is a
% uniform operator and operates on formulas. Let $\BB := \BB_{\setop} \uplus
% \BS$ and let $\rho$ be a relational vocabulary. We fix a $\PT$-uniform family
% of transparent symmetric $(\BB, \rho)$-circuits $\mathcal{C} = (C_n)_{n \in
% \nats}$. Let $q$ be the arity of the query defined by $\mathcal{C}$. Let $n_0$
% and $k$ be the constants in the statement of
% Lemma~\ref{lem:row-column-supports}.

% ---------------------------------------------------------------------

% that determines the evaluate

% $\eta \in A^{\consp(g)}$ we can define a structure $M^{g, \eta}_\equiv$ such
% that $g$ evaluate to



% with a set


% order to deal with this difficulty, we show that for every gate we can define
% a corresponding structure using an interpretation in logic such that applying
% the operator to this interpretation evaluates the gate. This chapter is
% divided into two sections. In the first section we show how to associate with
% each gate the requisite structure, and we show that this structure does indeed
% determine the evaluation of $g$. In the second section we complete the
% definition of the formula in the logic. In particular, we show that the
% structure associated with $g$ is definable by an interpretation.




% for an input $\mathcal{A}$. We show that we can recursively construct


% From this result, and the constant bound on the size of a support (see
% Theorem~\ref{}), we can encode the set of assignments to the support of $g$
% for which it evaluates to true. Third, we show


% We It follows from Theorem~\ref{} to show that the set of assignments to the
% support of $g$




% depends only

% Theorem~\ref{} how to recursively evaluate the gates in the circuit,
% characterising those bijections for which a given . Third, we use this formula
% to evaluate the output gates and thus define a formula expressing the same
% query as the family of circuits. The first and third steps in this proof are
% almost immediate, and so the vast majority of this chapter is concerned with
% the second step. In order to recursively evaluate a gate we first show that

% In order to prove the second step we use the Theorem~\ref{}




% In vast majority of this chapter is concerned with the second step in this
% argument. This argument relies on numerous results proved throughout this
% thesis. We use the constant bound guaranteed by Theorem~\ref{} in order to
% show that the set of all bijection that for a given structure make a gate
% evaluate to true can be succinctly encoded, we use the Lemma~\ref{} in order
% to translate transparent circuits to circuits with unique labels. We use the
% numerous polynomial-time algorithms in Section~\ref{} and the Immerman-Vardi
% theorem in order to show that many useful

% The central difficulty in this approach is in defining a recursive formula
% that evaluates a gate $g$ when $g$ is labelled by a Boolean function
% corresponding to a generalised operator. In order to deal with this
% difficulty, we show that for every gate we can define a corresponding
% structure using an interpretation in logic such that applying the operator to
% this interpretation evaluates the gate. This chapter is divided into two
% sections. In the first section we show how to associate with each gate the
% requisite structure, and we show that this structure does indeed determine the
% evaluation of $g$. In the second section we complete the definition of the
% formula in the logic. In particular, we show that the structure associated
% with $g$ is definable by an interpretation.

% It should be noted that Proposition~\ref{prop:translate-circuits-to-formulas}
% generalises the translation from Anderson and Dawar~\cite{} from $\PT$-uniform
% symmetric circuits with majority to formulas of $\FPC$. Anderson and Dawar
% useful


% that for any given structure $\mathcal{A}$ and $\gamma \in
% [n]^{\underline{A}}$ the evaluation of a gate depends just on the what
% $\gamma$ assigns to the support of $g$. We then show that for any internal
% gate $g$ and assignment to $\consp(g)$ we can define a structure $M$


\section {Associating a Gates with a Structure}
\label{sec:evaluating-circuits}
We first show that for a gate $g$ in a symmetric circuit $C$ of order $n$ the
evaluation of $g$ for an input structure $\mathcal{A}$ and bijection $\gamma \in
[n]^{\underline{A}}$ depends only on the mapping given by $\gamma$ to the
support of $g$.

\begin{lem}
  Let $\rho$ be a vocabulary and $\BB$ a basis, and $C$ be a symmetric $(\BB,
  \rho)$-circuit with unique labels. Let $n \in \nats$ be the order of $C$ and
  let $\mathcal{A} \in \fin{\rho, n}$. Let $g$ be an internal gate, $\eta \in
  A^{\underline{\consp(g)}}$, and $\gamma_1, \gamma_2 \in [n]^{\underline{A}}$
  such that $\gamma^{-1}_1 \sim \eta$ and $\gamma^{-1}_2 \sim \eta$. Then
  $L^{\gamma_1 \mathcal{A}}(g)$ and $L^{\gamma_2 \mathcal{A}}(g)$ are isomorphic
  and $C[\gamma_1 \mathcal{A}](g) = C[\gamma_2 \mathcal{A}](g)$.
	\label{lem:support-determines-evaluation}
\end{lem}
\begin{proof}
	We have that there exists a unique $\pi \in \sym_n$ such that $\pi \gamma_1 =
  \gamma_2$. Moreover, since $\gamma^{-1}_1$ and $\gamma^{-1}_2$ are both
  consistent with $\eta$, it follows that $\pi$ must fix $\consp(g)$ pointwise.
  From the definition of a support, we have that $\pi (g) = g$, and so $L(g)$ is
  isomorphic to $\pi L(g)$. Therefore there exists $\lambda \in \aut(g)$ such
  that $\pi L(g) = L(g) \lambda$, and so for all $a \in \ind(g)$,
	\begin{align*}
		L^{\gamma_1 \mathcal{A}}(g) (a) & = C [\gamma_1 \mathcal{A}](L(g)(a))                    \\
                                    & = C[\pi \gamma_1 \mathcal{A}][\pi L(g)(a)]            \\
                                    & = C[\gamma_2 \mathcal{A}][L(g)(\lambda(a))] \\
                                    & = L^{\gamma_2 \mathcal{A}}(g) (\lambda (a)).                 
	\end{align*}
	It follows that $L^{\gamma_1 \mathcal{A}}(g)$ and $L^{\gamma_2
    \mathcal{A}}(g)$ are isomorphic and $C[\gamma_1 \mathcal{A}](g) = \Sigma(g)
  (L^{\gamma_1 \mathcal{A}}(g)) = \Sigma(g) (L^{\gamma_2 \mathcal{A}}(g)) =
  C[\gamma_2 \mathcal{A}](g)$.
\end{proof}

For the remainder of this section we fix a basis $\BB$ such that there exists
$r_\BB \in \nats$ such that every relation in the vocabulary of a structured
function in $\BB$ has arity at most $r_{\BB}$. Let $\rho$ be a relational
vocabulary. We fix a $\PT$-uniform family of transparent symmetric $(\BB,
\rho)$-circuits $\mathcal{C} = (C_n)_{n \in \nats}$. Let $n_0$ and $k$ be the
constants in the statement of Lemma~\ref{lem:row-column-supports}. Let $n_1 =
\max (n_0, k \cdot r_{\BB})$. Fix some $n > n_1$ and $\mathcal{A} \in \fin{\rho,
  n}$. Let $C := \langle G, \Omega, \Sigma, \Lambda, L \rangle := C_n$.

For each $g \in G$ let $\Gamma_g:= \{\gamma \in [n]^{\underline{A}} : C[\gamma
\mathcal{A}](g) = 1 \}$ and let $\EV_g := \{ \eta \in A^{\underline{\consp(g)}}
: \exists \gamma \in \Gamma_g \, ,\eta \sim \gamma^{-1}\}$. In other words,
$\Gamma_g$ is the set of bijections for which $g$ evaluates to one and $\EV_g$
is the set of assignments to the support of $g$ that can be extended to a
bijection for which $g$ evaluates to one. It follows from
Lemma~\ref{lem:support-determines-evaluation} that $\Gamma_g$ is entirely
determined by $\EV_g$. It is important to note that, from the support theorem,
the domain of each $\eta \in \EV_g$ has cardinality at most $k$. We think of
$\EV_g$ as succinctly encoding $\Gamma_g$.

For the remainder of this section we fix a gate $g \in G$ and an assignment
$\eta \in A^{\underline{\consp(g)}}$. Let $\tau := (R, S, \zeta)$ be the
vocabulary of $g$, where $R = \{R_1, \ldots, R_r\}$ and $S = \{s_1, \ldots,
s_l\}$. For each $R_i \in R$ let $r_i$ denote the arity of $R_i$. For each $i
\in [l]$ let $X_i$ be the $i$th sort in the universe of $g$ and let $X :=
\uplus_{i \in [l]}X_i$. For each $h \in H_g$ there is some $(\vec{x}, R_i) \in
\ind(g)$ such that $L(g)(\vec{x}, R_i) = h$ and for each $j \in [r_i]$ we let
$\lab{j}{h}$ denote the $j$th element in the tuple $\vec{x}$. As in Chapter
\ref{chpt:support}, for each $x \in \universe{g}$ we abbreviate a few commonly
used symbols and let $\consp(x) := \consp_{\spstab{g}}(x)$, $\orb(x) :=
\orb_{\spstab{g}}(x)$, and $\stab(x) := \stab_{\spstab{g}}(x)$.

We aim to define a $\tau$-structure $M^{g, \eta}_{\equiv}$ such that for any
$\gamma \in [n]^{\underline{A}}$ with $\gamma^{-1} \sim \eta$ we have that
$M^{g, \eta}_{\equiv}$ is isomorphic to $L^{\gamma \mathcal{A}}(g)$. We define
$M^{g, \eta}_{\equiv}$ as follows. First, we define two helper functions
$\bar{J}^{g, \eta}$ and $J^{g, \eta}$. Second, we use these two helper functions
to define a $\tau$-structure $M^{g, \eta}$. Third, we define an equivalence
relation denoted by $\equiv$. Finally, we define $M^{g, \eta}_\equiv$ by taking
a quotient of $M^{g, \eta}$ by $\equiv$.


For each $h \in H_g$ let $A^h := \{\alpha \in A^{\underline{\consp(h)}} : \eta
\sim \alpha\}$ be the set of assignments to the support of $h$ that are
compatible with $\eta$. We should also like to consider sets of assignments to
the supports of elements of the universe of $g$. For each $x \in \universe{g}$
let $A^x:= \{\alpha \in A^{\underline{\consp(x)}} : \eta \sim \alpha\}$.

We now define the domain of the structure $M^{g, \eta}$. For each $i \in [l]$
let $\minorb{i} := \{\min (\orb(x)) : x \in X_i\}$ and let $I^{g, \eta}_{i} :=
\{(x, \alpha): x \in \minorb {i}, \alpha \in A^x\}$. Let $I^{g, \eta} :=
\uplus_{i \in [l]} I^{g, \eta}_i$. We think of each $I^{g, \eta}_i$ as encoding
copies of the elements of $X_i$ by indexing each orbit in $X_i$ by their minimal
element and then indexing the elements of the the assignments to the support of
the minimal element of that orbit.

We now define a function $\bar{J}^{g, \eta}$ that maps each element in
$\vatoms{\tau}{I^{g, \eta}}$ to a sequence of injections defined as follows. For
each $(((x_1, \alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i) \in
\vatoms{\tau}{I^{g, \eta}}$ we let $\bar{J}^{g, \eta}(((x_1, \alpha_1), \ldots
(x_{r_i}, \alpha_{r_i})), R_i) := (\bar{\sigma}_1, \ldots, \bar{\sigma}_{r_i})$,
where for each $j \in [r_i]$ we define $\bar{\sigma}_j\in
[n]^{\underline{\consp(x_j)}}$ recursively as follows. For each $u \in
\dom(\alpha_1)$ let $\bar{\sigma}_1(u) := u$ if $u \in \consp(g)$ and otherwise
let $\bar{\sigma}_1 (u)$ be the $k_u$th element of $[n] \setminus \consp(g)$,
where $k_u$ is such that $u$ is the $k_u$th element of $\dom(\alpha_j) \setminus
\consp(g)$. Suppose $j > 1$ and let $u \in \dom(\alpha_j)$. If $u \in \consp(g)$
let $\bar{\sigma}_j(u) := u$. If $u \not\in \consp(g)$ and there exists some
minimal $j' < j$ and $u' \in \dom (\alpha_{j'})$ such that $\alpha_j (u) =
\alpha_{j'}(u')$ then let $\bar{\sigma}_j (u) := \bar{\sigma}_{j'}(u')$.
Otherwise, let $\bar{\sigma}_j (u)$ be the $((j - 1)k + k_u)$th element of $[n]
\setminus \consp(g)$, where $k_u$ is such that $u$ is the $k_u$th element of
$\dom(\alpha_j) \setminus \consp(g)$.

\begin{lem}
  Let $(((x_1, \alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i) \in
  \vatoms{\tau}{I^{g, \eta}}$. Let $(\bar{\sigma}_1, \ldots, \bar{\sigma}_{r_i})
  := \bar{J}^{g, \eta}(((x_1, \alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i)$.
  Then for all $j \in [r_i]$ we have that
  \begin{myenum}
  \item for all $u \in \consp(g) \cap \dom (\bar{\sigma}_j)$, $\bar{\sigma}_j
    (u) = u$,
  \item $\bar{\sigma}_j$ is an injection, and
  \item for all $j' \in [r_i]$, $\alpha_j \bar{\sigma}^{-1}_j$ and $\alpha_{j'}
    \bar{\sigma}^{-1}_{j'}$ are compatible.
  \end{myenum}
  \label{lem:bar-J-construction}
\end{lem}
\begin{proof}
  Let $((x_1, \alpha_1), \ldots (x_{r_i}, \alpha_{r_i}), R_i) \in
  \vatoms{\tau}{I^{g, \eta}}$ and let $(\bar{\sigma}_1, \ldots,
  \bar{\sigma}_{r_i}) := \bar{J}^{g, \eta}((x_1, \alpha_1), \ldots (x_{r_i},
  \alpha_{r_i}), R_i)$. It is easy to see that for all $j \in [r_i]$ we have for
  all $u \in \consp(g) \cap \dom (\bar{\sigma}_j)$ that $\bar{\sigma}_j (u) =
  u$. We now prove by induction that for all $j \in [r_i]$, $\bar{\sigma}_j$ is
  an injection and for all $j' < j$, $\alpha_j \bar{\sigma}^{-1}_j$ and
  $\alpha_{j'} \bar{\sigma}^{-1}_{j'}$ are compatible.

  Let $j \in [r_i]$. Suppose $j = 1$. Let $u, v \in \dom(\alpha_1)$ be such that
  $\bar{\sigma}_1(u) = \bar{\sigma}_1(v)$. Suppose $u \in \consp(g)$. Then $v
  \in \consp(g)$, as if $v \not\in \consp(g)$ then, from the definition of
  $\bar{\sigma}_1$, we have $\bar{\sigma}_1 (v) \not\in \consp(g)$, but
  $\bar{\sigma}_1(v) = \bar{\sigma}_1(u) = u \in \consp(g)$. It follows that $u
  = \bar{\sigma}_1(u) = \bar{\sigma}_1(v) = v$. Otherwise, suppose $u \not\in
  \consp(g)$. Then $v \not\in \consp(g)$. We have $\bar{\sigma}_1(u)$ is the
  $k_u$th element of $[n] \setminus \consp(g)$, where $k_u$ is such that $u$ is
  the $k_u$th element of $\dom(\alpha_1) \setminus \consp(g)$ and
  $\bar{\sigma}_1(v)$ is the $k_v$th element of $[n] \setminus \consp(g)$ where
  $k_v$ is such that $v$ is the $k_v$th element of $\dom(\alpha_1) \setminus
  \consp(g)$. But $\bar{\sigma}_1(u) = \bar{\sigma}_1 (v)$ and so $k_u = k_v$
  and $u = v$. It follows that $\bar{\sigma}_1$ is an injection. This completes
  the proof of the base case.

  Suppose $j > 1$ and suppose the induction hypothesis holds for all $j' < j$.
  It can be shown, following a very similar approach as for the base case, that
  $\bar{\sigma}_j$ is an injection. Let $j' < j$. We first prove a claim.
  
  \begin{claim}
    Let $u \in \dom(\alpha_j \bar{\sigma}^{-1}_j)$ and $u' \in
    \dom(\alpha_{j'}\bar{\sigma}^{-1}_{j'})$. Then $\alpha_j
    (\bar{\sigma}^{-1}_j(u)) = \alpha_{j'}(\bar{\sigma}^{-1}_{j'}(u'))$ if, and
    only if, $u = u'$.
    \label{claim:compatibility}
  \end{claim}
  \begin{proof}
    \begin{myenum}
    \item[`$\Rightarrow$'] Suppose $\alpha_j (\bar{\sigma}^{-1}_j(u)) =
      \alpha_{j'}(\bar{\sigma}^{-1}_{j'}(u'))$. If $u \in \consp(g)$ then
      $\eta(u') = \alpha_{j'}(u') = \alpha_{j'} (\bar{\sigma}^{-1}_{j'}(u')) =
      \alpha_j (\bar{\sigma}^{-1}_j(u)) = \alpha_j(u) = \eta (u)$ and, since
      $\eta$ is an injection, it follows that $u = u'$. Suppose $u \not\in
      \consp(g)$. Since $\alpha_{j}(\bar{\sigma}^{-1}_{j}(u)) =
      \alpha_{j'}(\bar{\sigma}^{-1}_{j'}(u'))$, it follows that there exists a
      minimal $j'' < j$ and $u'' \in \dom(\alpha_{j''})$ such that $
      \alpha_{j}\bar{\sigma}^{-1}_{j}(u) = \alpha_{j'}
      \bar{\sigma}^{-1}_{j'}(u') = \alpha_{j''}(u'')$. Then $u =
      \bar{\sigma}_j(\bar{\sigma}^{-1}_j (u)) = \bar{\sigma}_{j''}(u'') =
      \bar{\sigma}_{j'}(\bar{\sigma}^{-1}_{j'} (u')) = u'$.

    \item[`$\Leftarrow$'] Suppose $u = u'$. Suppose that both $u \not\in
      \consp(g)$ and for all $j'' < j$ and all $u'' \in \dom(\alpha_{j''})$ we
      have $\alpha_j(\bar{\sigma}^{-1}_j(u)) \neq \alpha_{j''}(u'')$. Then $u >
      u_1$, where $u_1$ is the $(j-1)k$th element in $[n] \setminus \consp(g)$.
      Let $j'' < j$ and $u'' \in \dom(\alpha_{j''})$. If $u'' \in \consp(g)$
      then $u \neq u'' = \bar{\sigma}_{j''}(u'')$. Otherwise $u'' \not\in
      \consp(g)$ and it can be shown that $\bar{\sigma}_{j''}(u'') \leq u_2 \leq
      u_1$, where $u_2$ is the $((j'' - 1)k + k)$th element of $[n] \setminus
      \consp(g)$. It follows that $\bar{\sigma}_{j''}(u'') \leq u_1< a$ and so
      $u \neq \bar{\sigma}_{j''}(u'')$. Thus, for all $j'' \leq j$ we have $u
      \not\in \img(\bar{\sigma}_{j''})$. Then $u \not\in \dom(\alpha_{j'}
      \bar{\sigma}^{-1}_{j'})$. But this is a contradiction as $u = u' \in
      \dom(\alpha_{j'} \bar{\sigma}^{-1}_{j'})$.

      It follows that either $u \in \consp(g)$ or there exists $j'' < j$ and
      $u'' \in \dom(\alpha_{j''})$ such that $\alpha_j(\bar{\sigma}^{-1}_j(u)) =
      \alpha_{j''}(u'')$. If $u \in \consp(g)$ then $\bar{\sigma}_{j}(u) = u =
      u' = \bar{\sigma}_{j'}(u')$ and so $\alpha_j \bar{\sigma}^{-1}_j(u) =
      \alpha_j (u) = \eta (u) = \eta (u') = \alpha_{j'}(u') =
      \alpha_{j'}\bar{\sigma}^{-1}_{j'}(u')$. Suppose $u \not\in \consp(g)$. Let
      $j'' < j$ be minimal such that there exists $u'' \in \dom(\alpha_{j''})$
      such that $\alpha_{j} (\bar{\sigma}^{-1}_{j}(u)) = \alpha_{j''} (u'')$.
      Then $u' = u = \bar{\sigma}_j (\bar{\sigma}^{-1}_{j}(u)) =
      \bar{\sigma}_{j'}(u'')$. It follows that $u'' \in
      \dom(\alpha_{j'}\bar{\sigma}^{-1}_{j'})$. From the induction hypothesis we
      have that $\alpha_{j'}\bar{\sigma}^{-1}_{j'}$ and
      $\alpha_{j''}\bar{\sigma}^{-1}_{j''}$ are compatible, and so
      $\alpha_{j'}\bar{\sigma}^{-1}_{j'}(u') =
      \alpha_{j''}\bar{\sigma}^{-1}_{j''}(\bar{\sigma}_{j''}(u'')) =
      \alpha_{j''}(u'') = \alpha_{j} (\bar{\sigma}^{-1}_{j}(u))$.
    \end{myenum}
  \end{proof}

  Let $u \in \dom(\alpha_{j}\bar{\sigma}^{-1}_j) \cap
  \dom(\alpha_{j'}\bar{\sigma}^{-1}_{j'})$. Then, from
  Claim~\ref{claim:compatibility}, it follows that $\alpha_j
  (\bar{\sigma}^{-1}_j(u)) = \alpha_{j'}(\bar{\sigma}^{-1}_{j'}(u))$. Let $u \in
  \dom(\alpha_{j}\bar{\sigma}^{-1}_j) \setminus
  \dom(\alpha_{j'}\bar{\sigma}^{-1}_{j'})$ and $u' \in
  \dom(\alpha_{j'}\bar{\sigma}^{-1}_{j'}) \setminus
  \dom(\alpha_{j}\bar{\sigma}^{-1}_j)$. Then, from
  Claim~\ref{claim:compatibility}, since $u \neq u'$ it follows $\alpha_j
  (\bar{\sigma}^{-1}_j(u)) \neq \alpha_{j'}(\bar{\sigma}^{-1}_{j'}(u'))$. We
  conclude that $\alpha_{j}\bar{\sigma}^{-1}_{j}$ and
  $\alpha_{j'}\bar{\sigma}^{-1}_{j'}$ are compatible.
\end{proof}

Let $J^{g, \eta} : \vatoms{\tau}{I^{g, \eta}} \ra \{ (h, \epsilon) : h \in H_g,
\epsilon \in A^h\}$ be defined as follows. Let $(((x_1, \alpha_1), \ldots
(x_{r_i}, \alpha_{r_i})), R_i) \in \vatoms{\tau}{I^{g, \eta}}$. Let
$(\bar{\sigma}_1, \ldots, \bar{\sigma}_{r_i}) := \bar{J}^{g, \eta}(((x_1,
\alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i)$. For every $j \in [r_i]$ let
$\sigma_j \in \spstab{g}$ be such that for all $u \in \consp(x_j)$, $\sigma_j
(u) = \bar{\sigma}_j(u)$. Let $h := L(g)((\sigma (x_1), \ldots, \sigma
(x_{r_i})), R_i)$ and let $\epsilon := \restr{(\alpha_1 \bar{\sigma}^{-1}_1
  \vert \ldots \vert \alpha_{r_i} \bar{\sigma}^{-1}_{r_i})}{\consp(h)}$. Notice
that the compatibility condition needed for the definition of $\epsilon$ follows
from Lemma~\ref{lem:bar-J-construction}. Then $J^{g, \eta} (((x_1, \alpha_1),
\ldots (x_{r_i}, \alpha_{r_i})), R_i) := (h, \epsilon)$.

Let $M^{g, \eta} : \vatoms{\tau}{I^{g, \eta}} \ra \{0,1\}$ be defined for
$(((x_1, \alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i) \in
\vatoms{\tau}{I^{g, \eta}}$ as follows. Let $(h, \epsilon) := J^{g, \eta}(((x_1,
\alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i)$. Then $M^{g, \eta}(((x_1,
\alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i) = 1$ if, and only if, $\epsilon
\in \EV_h$.

We now show that for each $\gamma \in [n]^{\underline{A}}$ with $\gamma^{-1}
\sim \eta$ and each $h \in H_g$ there is a function that maps $A^h$ to $\orb(h)$
and for each $x \in \universe{g}$ a function that maps $A^x$ to $\orb(x)$. Let
$\gamma \in [n]^{\underline{A}}$ be such that $\gamma^{-1} \sim \eta$. Let $h
\in H_g$. For each $\epsilon \in A^{h}$ let $\Pi^{\gamma}_{\epsilon}$ be any
permutation in $\spstab{g}$ such that $\Pi^{\gamma}_\epsilon (u) = \gamma
(\epsilon(u))$ for all $u \in \consp(h)$. It follows from
Lemma~\ref{lem:support-determine-action} that $\Pi^{\gamma}_\epsilon(h)$ is
defined independently of the choice of permutation. We thus have that the
function $\epsilon \mapsto \Pi^{\gamma}_{\epsilon}(h)$ is well-defined. Let $x
\in X$. For each $\alpha \in A^{x}$ let $\Pi^{\gamma}_{\alpha}$ be any
permutation in $\spstab{g}$ such that $\Pi^{\gamma}_\alpha (u) = \gamma
(\alpha(u))$ for all $u \in \consp(x)$. It follows similarly that the function
$\alpha \mapsto \Pi^{\gamma}_{\alpha} (x)$ is well-defined.

Let $\gamma \in [n]^{\underline{A}}$ be such that $\eta \sim \gamma^{-1}$. For
each $i \in [l]$ let $P^{\gamma}_i: I^{g, \eta}_i \rightarrow X_i$ be defined by
$P^{\gamma} (x, \alpha) := \Pi^{\gamma}_{\alpha}(x)$ for all $(x, \alpha) \in
I^{g, \eta}_i$. Let $P^{\gamma} = \uplus_{i \in [l]} P^{\gamma}_i$. We aim to
show that $P^{\gamma}$ is a surjective homomorphism from $M^{g, \eta}$ to
$L^{\gamma \mathcal{A}}(g)$. We first prove two useful lemmas.
\begin{lem}
  Let $\gamma \in [n]^{\underline{A}}$ be such that $\gamma^{-1} \sim \gamma$.
  Let $(((x_1, \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})), R_i) \in
  \vatoms{\tau}{I^{g, \eta}}$ and let $(h, \epsilon) := J^{g, \eta}(((x_1,
  \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})), R_i)$. Then
  $\Pi^{\gamma}_{\epsilon} (h) = L(g)(((\Pi^{\gamma}_{\alpha_1} (x_1), \ldots,
  \Pi^{\gamma}_{\alpha_{r_i}}(x_{r_i}), R_i))$.
  \label{lem:defining-h-from-index}
\end{lem}
\begin{proof}
  Let $j \in [r_i]$ and let $u \in \consp(x_{j})$. It follows from
  Lemma~\ref{lem:row-column-supports} that $\sigma_j(u) \in \consp(\lab{j}{h})
  \subseteq \consp(h) \cup \consp(g)$, and so either $\sigma_j (u) \in
  \consp(g)$ or $\sigma_j (u) \in \consp(h)$. Suppose $\sigma_j (u) \in
  \consp(g)$. We have that $\sigma_j$ and $\Pi^{\gamma}_{\epsilon}$, and
  $\Pi^{\gamma}_{\alpha_j}$ are in $\spstab{g}$, and so $\Pi^{\gamma}_{\epsilon}
  (\sigma_j (u)) = u = \Pi^{\gamma}_{\alpha_j}(u)$. Suppose instead that
  $\sigma_j(u) \in \consp(h)$. Then $\Pi^{\gamma}_{\epsilon}(\sigma_j (u)) =
  \gamma (\epsilon (\sigma_j(u))) = \gamma (\alpha_j (\bar{\sigma}^{-1}_j
  (\sigma_j (u)))) = \gamma(\alpha_j (u)) = \Pi^{\gamma}_{\alpha_j} (u)$. It
  follows that $\Pi^{\gamma}_{\epsilon} (\sigma_j(x_j)) =
  \Pi^{\gamma}_{\alpha_j}(x_j)$ and so
  \begin{align*}
    \Pi^{\gamma}_{\epsilon} (h) &= \Pi^{\gamma}_{\epsilon} (L(g)((\sigma_1 (x_1), \ldots, \sigma_{r_i}(x_{r_i})), R_i)) \\ &= L(g)((\Pi^{\gamma}_{\epsilon}(\sigma_1 (x_1)), \ldots,\Pi^{\gamma}_{\epsilon}(\sigma_{r_i}(x_{r_i}))), R_i) \\ &= L(g)((\Pi^{\gamma}_{\alpha_1}(x_1), \ldots,\Pi^{\gamma}_{\alpha_{r_i}}(x_{r_i})), R_i)
  \end{align*}
\end{proof}

% Let $M^{g, \eta} : \vatoms{\tau}{I^{g, \eta}} \ra \{0,1\}$ be defined as
% follows. Let $(((x_1, \alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i) \in
% \vatoms{\tau}{I^{g, \eta}}$ and $(h, \epsilon) := J^{g, \eta}(((x_1,
% \alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i)$. Then $M^{g, \eta}(((x_1,
% \alpha_1), \ldots (x_{r_i}, \alpha_{r_i}), R_i)) = 1$ if, and only if,
% $\epsilon \in \EV_h$.

% Let $\gamma \in [n]^{\underline{A}}$ be such that $\eta \sim \gamma^{-1}$. For
% each $i \in [l]$ let $P^{\gamma}_i: I^{g, \eta}_i \rightarrow X_i$ be defined
% by $P^{\gamma} (x, \alpha) := \Pi^{\gamma}_{\alpha}(x)$ for all $(x, \alpha)
% \in I^{g, \eta}_i$. Let $P^{\gamma} = \uplus_{i \in [l]} P^{\gamma}_i$.

\begin{lem}
	Let $\gamma\in [n]^{\underline{A}}$ be such that $\gamma^{-1} \sim \eta$ and
  $h \in H_g$. Then $\epsilon \in \EV_h$ if, and only if, $C[\gamma
  \mathcal{A}](\Pi^{\gamma}_{\epsilon} (h)) = 1$.
  \label{lem:translate-EV-circuits}
\end{lem}
\begin{proof}
  From the definition of $\EV_h$ it follows that $\epsilon \in \EV_h$ if, and
  only if, there exists $\delta_{\epsilon} \in [n]^{\underline{A}}$ such that
  $\delta^{-1}_{\epsilon} \sim \eta$, $\delta^{-1}_{\epsilon} \sim \epsilon$,
  and $C[\delta_{\epsilon} \mathcal{A}](h) = 1$. Let $\pi_{\epsilon} := \gamma
  \delta^{-1}_{\epsilon}$. Notice that $\pi \in \spstab{g}$ and $\pi_{\epsilon}
  \delta_{\epsilon} = \gamma$. For $a \in \consp(h)$ we have $\gamma
  (\epsilon(a)) = \pi_{\epsilon} (\delta_{\epsilon} (\epsilon (a))) =
  \pi_{\epsilon}(a)$ (the second equality follows from the fact that
  $\delta^{-1}_{\epsilon} \sim \epsilon$ and so $\delta_{\epsilon} (\epsilon
  (a)) = a$). It follows that for all $a \in \consp(h)$ we have
  $\Pi^{\gamma}_\epsilon (a) = \gamma (\epsilon (a)) = \pi_{\epsilon}(a)$, and
  so $\Pi^{\gamma}_{\epsilon}(h) = \pi_{\epsilon}(h)$. Thus
  \begin{align*}
    \epsilon \in \EV_h \iff C[\delta_{\epsilon} \mathcal{A}](h) = 1 
    & \iff C[\pi_\epsilon \delta_{\epsilon} \mathcal{A}](\pi_{\epsilon} (h)) = 1 \\
    & \iff C[\gamma \mathcal{A}](\pi_{\epsilon} (h)) = 1 
      \iff C[\gamma \mathcal{A}](\Pi^{\gamma}_{\epsilon}(h)) = 1.
  \end{align*}
\end{proof}

We now show that $P^{\gamma}$ is a homomorphism from $M^{g, \eta}$ to $L^{\gamma
  \mathcal{A}}(g)$.

\begin{prop}
  Let $(((x_1, \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})), R_i) \in \dom (M^{g,
    \eta})$. Let $\gamma \in [n]^{\underline{A}}$ be such that $ \gamma^{-1}
  \sim \eta$. Then $M^{g, \eta}(((x_1, \alpha_1), \ldots, (x_{r_i},
  \alpha_{r_i})), R_i) = L^{\gamma\mathcal{A}}(g)(P^{\gamma}(x_1, \alpha_1),
  \ldots, P^{\gamma}(x_{r_i}, \alpha_{r_i})), R_i)$.
	\label{prop:M-to-L-homomorphism}
\end{prop}
\begin{proof}
  Let $((x_1, \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})), R_i) \in \dom (M^{g,
    \eta})$. Let $\gamma \in [n]^{\underline{A}}$ be such that $ \gamma^{-1}
  \sim \eta$. Let $(h, \epsilon) := J^{g, \eta}((x_1, \alpha_1), \ldots,
  (x_{r_i}, \alpha_{r_i})), R_i)$. Then $M^{g, \eta}(((x_1, \alpha_1), \ldots,
  (x_{r_i}, \alpha_{r_i})), R_i) = 1$ if, and only if, $\epsilon \in \EV_h$ if,
  and only if, $C[\gamma \mathcal{A}] (\Pi^{\gamma}_{\epsilon}(h)) = 1$ if, and
  only if, $C[\gamma \mathcal{A}] (L(g)((\Pi^{\gamma}_{\alpha_1} (x_1), \ldots,
  \Pi^{\gamma}_{\alpha_{r_i}}(x_j)), R_i)) = 1$. The second equivalence follows
  from Lemma~\ref{lem:translate-EV-circuits} and the third equivalence follows
  from Lemma~\ref{lem:defining-h-from-index}.
\end{proof}

We now show that $P^{\gamma}$ is a surjection (and hence an epimorphism).

\begin{lem} 
	If $\gamma \in [n]^{\underline{A}}$ is such that $\gamma^{-1} \sim \eta$, then
  $P^{\gamma}$ is surjective.
  \label{lem:M-to-L-surjective}
\end{lem}
\begin{proof}
  Let $x \in X$. Let $y = \min(\orb(x))$. There exists $\sigma \in \spstab{g}$
  such that $\sigma (y) = x$. Let $\alpha := \gamma^{-1}
  \restr{\sigma}{\consp(y)}$. Then for each $u \in \consp(y) \cap \consp(g)$ we
  have $\alpha(u) = \gamma^{-1} \restr{\sigma}{\consp(y)} (u) = \gamma^{-1}(u) =
  \eta (u)$, and so $\alpha \in A^y$. For each $u \in \consp(y)$ we have
  $\Pi^{\gamma}_\alpha(u) = \gamma (\alpha(u)) = \gamma(\gamma^{-1}
  \restr{\sigma}{\consp(y)}(u)) = \sigma (u)$. It follows that $P^{\gamma}(y,
  \alpha) = \Pi^{\gamma}_\alpha(y) = \sigma (y) = x$.
\end{proof}

We have shown that $P^{\gamma}$ is an epimorphism. We next prove a necessary and
sufficient condition for $P^{\gamma}$ to be an injection. Before we state this
result we first introduce an equivalence relation.

\begin{definition}
  % Let $x \in \universe{g}$ and let $\alpha, \beta \in A_x$. We say that
  % $\alpha$
  % and $\beta$ are \emph{mutually stable} on $x$ if there exists $\pi \in
  % \stab(x)$ such that $\alpha (u) = \beta (\pi (u))$ for all $u \in
  % \consp(x)$.
  % We write $\alpha \equiv_x \beta$ to denote that $\alpha$ and $\beta$ are
  % mutually stable with respect to $x$. Notice that mutual stability on $x$ is
  % an
  % equivalence relation on $A_x$.

  % Let $i \in [l]$. We say that $(x, \alpha), (y, \beta) \in I^{g, \eta}$ are
  % \emph{mutually stable} if $x = y$ and $\alpha \equiv_x \beta$. We write $(x,
  % \alpha) \equiv (y, \beta)$ to denote that $(x, \alpha)$ and $(y, \beta)$ are
  % mutually stable. Notice that mutual stability is an equivalence relation on
  % $I^{g, \eta}$.
  We say that $(x, \alpha), (y, \beta) \in I^{g, \eta}$ are \emph{mutually
    stable} if $x = y$ and there exists $\pi \in \stab(x)$ such that $\alpha (u)
  = \beta(\pi (u))$ for all $u \in \consp(x)$. We write $(x, \alpha) \equiv (y,
  \beta)$ to denote that $(x, \alpha)$ and $(y, \beta)$ are mutually stable.
\end{definition}

\begin{lem}
  Let $\gamma \in [n]^{\underline{A}}$ be such that $\gamma^{-1} \sim \eta$. For
  each $(x, \alpha), (y, \beta) \in I^{g, \eta}$ we have that $(x, \alpha)
  \equiv (y, \beta)$ if, and only if, $P^{\gamma}(x, \alpha) = P^{\gamma}(y,
  \beta)$.
	\label{lem:quot-well-defined}
\end{lem}
\begin{proof}
  \begin{myenum}
  \item[`$\Rightarrow$'] Let $(x, \alpha), (y, \beta) \in I^{g, \eta}$ and
    suppose $(x, \alpha) \equiv (y, \beta)$. Since $(x, \alpha) \equiv (y,
    \beta)$ there exists $\pi \in \stab(x)$ such that for all $u \in \consp(x)$,
    $\alpha (u) = \beta (\pi (u))$ and $\pi (x) = x = y = \pi (y)$. For all $u
    \in \stab(x)$ we have $\Pi^{\gamma}_{\beta} (\pi (u)) = \gamma (\beta (\pi
    (u))) = \gamma (\alpha (u)) = \Pi^{\gamma}_{\alpha}(u)$, and so
    $\Pi^{\gamma}_{\beta}(\pi (x)) = \Pi^{\gamma}_{\beta}(\pi (y)) =
    \Pi^{\gamma}_{\alpha}(y) = \Pi^{\gamma}_{\alpha}(x)$. It follows that
    $P^{\gamma}(y, \beta) = \Pi^{\gamma}_{\beta} (y) = \Pi^{\gamma}_{\beta} (\pi
    (y)) = \Pi^{\gamma}_{\alpha}(x) = P^{\gamma}(x, \alpha)$.
  \item [`$\Leftarrow$'] Let $(x, \alpha), (y, \beta) \in I^{g, \eta}$ be such
    that $P^{\gamma} (x, \alpha) = P^{\gamma}_{\equiv} (y, \beta)$. Then
    $\Pi^{\gamma}_{\alpha}(x) = \Pi^{\gamma}_\beta(y)$. It follows that $x \in
    \orb(y)$, and so $\orb (x) = \orb (y)$ and $x = \min(\orb(x)) =
    \min(\orb(y)) = y$. Let $\sigma :=(\Pi^{\gamma}_\beta)^{-1}
    \Pi^{\gamma}_\alpha$. Notice that $\sigma (x) = (\Pi^{\gamma}_\beta)^{-1}
    \Pi^{\gamma}_\alpha (x) = y = x$, and so $\sigma \in \stab(x)$. Let $u \in
    \consp(x)$. Then $\gamma (\alpha (u)) = \Pi^\gamma_{\alpha}(u) =
    \Pi^{\gamma}_{\beta}(\sigma (u)) = \gamma (\beta (\sigma (u)))$. Since
    $\gamma$ is an injection it follows that $\alpha (u) = \beta (\sigma (u))$
    and so $(x, \alpha) \equiv (y, \beta)$.
  \end{myenum}
\end{proof}

It follows from Lemma~\ref{lem:quot-well-defined} that $P^{\gamma}$ is injective
if, and only if, the mutually stability equivalence relation collapses to
equality if, and only if, $\stab(x) = \spstab{x}$ for each $x \in X$. From this
we can conclude that $P^{\gamma}$ is not, in general, an injection and $M^{g,
  \eta}$ is not, in general, isomorphic to $L^{\gamma \mathcal{A}}$. This result
also suggests that we can define an isomorphism and isomorphic structure by
taking quotients of $P^{\gamma}$ and $M^{g, \eta}$, respectively. Importantly,
Lemma~\ref{lem:quot-well-defined} gives us that $P^{\gamma}$ is a congruence
with respect to mutual stability. We now show that $M^{g, \eta}$ is also a
congruence with respect to mutual stability.
% \begin{lem}
%   Let $(x, \alpha), (y, \beta) \in I^{g, \eta}$ and let $\gamma \in
%   [n]^{\underline{A}}$ be such that $\gamma^{-1} \sim \eta$. If $(x, \alpha)
%   \equiv (y, \beta)$ then $P^{\gamma}(x, \alpha) = P^{\gamma}(y, \beta)$.
%   \label{lem:quot-well-defined}
% \end{lem}
% \begin{proof}
%   Let $(x, \alpha), (y, \beta) \in I^{g, \eta}$ and suppose $(x, \alpha)
%   \equiv (y, \beta)$. Since $(x, \alpha) \equiv (y, \beta)$ we have that there
%   exists $\pi \in \stab(x)$ such that for all $u \in \stab(x)$, $\alpha (u) =
%   \beta (\pi (u))$ and $\pi (x) = x = y = \pi (y)$. For all $u \in \stab(x)$
%   we have $\Pi^{\gamma}_{\beta} (\pi (u)) = \gamma (\beta (\pi (u))) = \gamma
%   (\alpha (u)) = \Pi^{\gamma}_{\alpha}(u)$, and so $\Pi^{\gamma}_{\beta}(\pi
%   (x)) = \Pi^{\gamma}_{\beta}(\pi (y)) = \Pi^{\gamma}_{\alpha}(y) =
%   \Pi^{\gamma}_{\alpha}(x)$. It follows that $P^{\gamma}(y, \beta) =
%   \Pi^{\gamma}_{\beta} (y) = \Pi^{\gamma}_{\beta} (\pi (y)) =
%   \Pi^{\gamma}_{\alpha}(x) = P^{\gamma}(x, \alpha)$.
% \end{proof}

\begin{lem}
  Let $(((x_1, \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})), R_i), (((y_1,
  \beta_1), \ldots, (y_{r_{j}}, \beta_{r_j})), R_j) \in \vatoms{\tau}{I^{g,
      \eta} \,}$. Suppose $R_i = R_j$ and for all $m \in [r_i]$ we have $(x_m,
  \alpha_m) \equiv (y_m, \beta_m)$. It follows that $M^{g, \eta}(((x_1,
  \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})), R_j) = M^{g, \eta} (((y_1,
  \beta_1), \ldots, (y_{r_{j}}, \beta_{r_j})), R_j)$.
  \label{lem:M-quot-well-defined}
\end{lem}
\begin{proof}
  Let $(((x_1, \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})), R_i), (((y_1,
  \beta_1), \ldots, (y_{r_{j}}, \beta_{r_j})), R_j) \in \vatoms{\tau}{I^{g,
      \eta} \,}$ and suppose $R_i = R_j$ and for all $m \in [r_i]$ we have
  $(x_m, \alpha_m) \equiv (y_m, \beta_m)$. Then
  \begin{align*}
    M^{g, \eta}(((x_1, \alpha_1), \ldots (x_{r_i}, \alpha_{r_i})), R_i)  &= L^{\gamma \mathcal{A}}(g)((P^{\gamma}(x_1, \alpha_1), \ldots, P^{\gamma}(x_{r_i}, \alpha_{r_i})), R_i)\\
                                                                         &= L^{\gamma \mathcal{A}}(g)((P^{\gamma}(y_1, \beta_1), \ldots, P^{\gamma}(y_{r_j}, \beta_{r_j})), R_j) \\
                                                                         &= M^{g, \eta}(((y_1, \beta_1), \ldots (y_{r_i}, \beta_{r_j})), R_j).
  \end{align*}
  The first and third equivalences follows from
  Proposition~\ref{prop:M-to-L-homomorphism}. The second equivalence follows
  from Lemma~\ref{lem:quot-well-defined}
\end{proof}

We now define the quotients of $M^{g, \eta}$ and $P^{\gamma}$ with respect to
mutual stability. For each $i \in [l]$ let $I^{g, \eta}_{\equiv, i} :=
\quot{I^{g, \eta}_i}{\equiv}$ and let $I^{g, \eta}_{\equiv} := \uplus_{i \in
  [l]}I^{g, \eta}_{\equiv, i}$. For each $\gamma \in [n]^{\underline{A}}$ such
that $\gamma^{-1} \sim \eta$ let $P^{\gamma}_{\equiv, i}: I^{g, \eta}_{\equiv,
  i}\ra X_i$ be defined by $P^{\gamma}_{\equiv, i} ([(x, \alpha)]) :=
P^{\gamma}_i (x, \alpha)$ for all $([(x, \alpha)]) \in I^{g, \eta}_{\equiv, i}$.
Let $P^{\gamma}_{\equiv} := \uplus_{i \in [l]}P^{\gamma}_{\equiv, i}$. It
follows from Lemma~\ref{lem:quot-well-defined} that all of these functions are
well-defined. Let $M^{g, \eta}_\equiv : \vatoms{\tau}{I^{g, \eta}_\equiv} \ra
\{0,1\}$ be defined by $M^{g, \eta}_{\equiv} (([(x_1, \alpha_1)], \ldots,
[(x_{r_i}, \alpha_{r_i})]), R_i) = M(((x_1, \alpha_1), \ldots, (x_{r_i},
\alpha_{r_i})), R_i)$ for each $(([(x_1, \alpha_1)], \ldots, [(x_{r_i},
\alpha_{r_i})]), R_i) \in \vatoms{\tau}{I^{g, \eta}_\equiv}$. It follows from
Lemma~\ref{lem:M-quot-well-defined} that this function is well-defined. We now
prove the main result of this section.
\begin{prop}
	Let $\gamma \in [n]^{\underline{U}}$ be such that $\gamma^{-1} \sim \eta$.
  Then $M^{g, \eta}_{\equiv}$ is isomorphic to $L^{\gamma\mathcal{A}}(g)$.
	\label{prop:M-to-L-isomorphism}
\end{prop}
\begin{proof}
  Let $(([(x_1, \alpha_1)], \ldots, [(x_{r_i}, \alpha_{r_i})]), R_i) \in \dom
  (M^{g, \eta}_\equiv)$. Then
  \begin{align*}
    M^{g, \eta}_\equiv (([(x_1, \alpha_1)], \ldots, [(x_{r_i},
    \alpha_{r_i})]), R_i) &= M^{g, \eta}(((x_1, \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})),
                            R_i)\\
                          &= L^{\gamma\mathcal{A}}(g)((P^{\gamma}(x_1, \alpha_1), \ldots,
                            P^{\gamma}(x_{r_i}, \alpha_{r_i})), R_i)\\ 
                          &= L^{\gamma\mathcal{A}}(g)((P^{\gamma}_{\equiv}([(x_1, \alpha_1)]), \ldots,
                            P^{\gamma}_{\equiv}([(x_{r_i}, \alpha_{r_i}))]), R_i)
  \end{align*}
  The first equality follows from the definition of $M^{g, \eta}_\equiv$. The
  second equality follows from Proposition~\ref{prop:M-to-L-homomorphism}. The
  third equality follows from the definition of $P^{\gamma}_\equiv$. We conclude
  that $P^{\gamma}_{\equiv}$ is a homomorphism from $M^{g, \eta}_\equiv$ to
  $L^{\gamma\mathcal{A}}(g)$.

  Let $x \in \universe{g}$. It follows from Lemma~\ref{lem:M-to-L-surjective}
  that $P^{\gamma}$ is surjective and so there exists $(y, \alpha) \in I^{g,
    \eta}$ such that $P^{\gamma}(y, \beta) = x$ and we have $P^{\gamma}_{\equiv}
  ([(y, \beta)])= P^{\gamma}_{\equiv} (y, \beta) = P^{\gamma}(y, \alpha) = x$.
  We conclude that $P^{\gamma}_{\equiv}$ is surjective.

  Let $[(x, \alpha)], [(y, \beta)] \in I^{g, \eta}_\equiv$ be such that
  $P^{\gamma}_{\equiv} ([(x, \alpha)]) = P^{\gamma}_{\equiv} ([(y, \beta)])$.
  Then $P^{\gamma} (x, \alpha) = P^{\gamma} (y, \beta)$ and so from
  Lemma~\ref{lem:quot-well-defined}, we have that $(x, \alpha) \equiv (y,
  \beta)$. We conclude that $P^{\gamma}_\equiv$ is injective, and the result
  follows.
\end{proof}

% \begin{prop}
%   Let $\gamma \in [n]^{\underline{U}}$ be such that $\gamma^{-1} \sim \eta$.
%   Then $L^{\gamma\mathcal{A}}(g)$ is isomorphic to $M_{\equiv}$.
%   \label{prop:M-to-L-isomorphism}
% \end{prop}
% \begin{proof}
%   Let $(([(x_1, \alpha_1)], \ldots, [(x_{r_i}, \alpha_{r_i})]), R_i) \in \dom
%   (M_\equiv)$. Then
%   \begin{align*}
%     M_\equiv (([(x_1, \alpha_1)], \ldots, [(x_{r_i},
%     \alpha_{r_i})]), R_i) &= M(((x_1, \alpha_1), \ldots, (x_{r_i}, \alpha_{r_i})),
%                             R_i)\\
%                           &= L^{\gamma\mathcal{A}}(g)((P^{\gamma}(x_1, \alpha_1), \ldots,
%                             P^{\gamma}(x_{r_i}, \alpha_{r_i})), R_i)\\ 
%                           &= L^{\gamma\mathcal{A}}(g)((P^{\gamma}_{\equiv}([(x_1, \alpha_1)]), \ldots,
%                             P^{\gamma}_{\equiv}([(x_{r_i}, \alpha_{r_i}))]), R_i)
%   \end{align*}
%   The first equality follows from the definition of $M_\equiv$. The second
%   equality follows from Proposition~\ref{}. The third equality follows from
%   Lemma~\ref{}. It follows that $\Pi_{\equiv}$ is a homomorphism from
%   $M_\equiv$ to $L^{\gamma\mathcal{A}}(g)$.

%   Let $x \in \universe{g}$. It follows from Lemma~\ref{} that $P^{\gamma}$ is
%   surjective. It follows that there exists $(y, \alpha) \in I$ such that
%   $P^{\gamma}(y, \alpha) = x$. Then $P^{\gamma}_{\equiv} ([(y, \alpha)])=
%   P^{\gamma}_{\equiv} (y, \alpha) = P^{\gamma}(y, \alpha) = x$. It follows
%   that $P^{\gamma}_{\equiv}$ is surjective.

%   Let $[(x, \alpha)], [(y, \beta)] \in I$ be such that $P^{\gamma}_{\equiv}
%   ([(x, \alpha)]) = P^{\gamma}_{\equiv} ([(y, \beta)])$. Then $P^{\gamma} (x,
%   \alpha) = P^{\gamma} (y, \beta)$ and so $\Pi^{\gamma}_{\alpha}(x) =
%   \Pi^{\gamma}_\beta(y)$. It follows that $x \in \orb(y)$, and so $\orb (x) =
%   \orb (y)$ and $x = \min(\orb(x)) = \min(\orb(y)) = y$. Let $\sigma
%   :=(\Pi^{\gamma}_\beta)^{-1} \Pi^{\gamma}_\alpha$. Notice that $\sigma (x) =
%   (\Pi^{\gamma}_\beta)^{-1} \Pi^{\gamma}_\alpha (x) = y = x$, and so $\sigma
%   \in \stab(x)$. Let $u \in \consp(x)$. Then $\gamma (\alpha (u)) =
%   \Pi^\gamma_{\alpha}(u) = \Pi^{\gamma}_{\beta}(\sigma (u)) = \gamma (\beta
%   (\sigma (u)))$. Since $\gamma$ is an injection it follows that $\alpha (u) =
%   \beta (\sigma (u))$. It follows that $\alpha \equiv_x \beta$ and so $[(x,
%   \alpha)] = [(y, \beta)]$. We conclude that $P^{\gamma}_\equiv$ is an
%   injection, and the result follows.
% \end{proof}



% ---------------------------------------------------------------------------
% ---------------------------------------------------------------------------
% ---------------------------------------------------------------------------
% ---------------------------------------------------------------------------
% ---------------------------------------------------------------------------
% ---------------------------------------------------------------------------
% ---------------------------------------------------------------------------
\section{Constructing a Formula}
\label{sec:translating-formulas-to-FPR}
% Let $\setop := \{\setop_1, \ldots, \setop_w\}$, where for each $i \in [w]$,
% $\setop_i$ is a uniform operator. Let $\rho$ be a vocabulary. Let $\mathcal{C}
% = (C_n)_{n \in \mathbb{N}}$ be a fixed $\PT$-uniform family of transparent
% symmetric $(\BB_{\setop}, \rho)$-circuits that defines a $q$-ary query. Our
% aim in this subsection is to define an $\FP^{\nats}(\setop)$-formula $Q$ such
% that for any $\rho$-structure $\mathcal{A}$ of size $n$, the $q$-ary query
% defined by $C_n$ for the input $\mathcal{A}$ is defined by $Q$ when
% interpreted in $\mathcal{A}$. For the rest of this section fix $n \in \nats$
% and $C_n := \langle G, \Sigma, \Omega, \Lambda, L \rangle \in \mathcal{C}$.

% Let $T := \{\AND, \OR, \NAND\} \cup \setop \cup \rho \cup \{0,1\}$. It follows
% from the Immerman-Vardi theorem~\cite{Immerman198686, Vardi:1982}, the
% $\PT$-uniformity of $\mathcal{C}$, and Lemma~\ref{lem:transparent-unique},
% that there is an $\FPC$-interpretation $\Phi := (\phi_G, \phi_\Omega,
% (\phi_{\Sigma, s})_{s \in T}, (\phi_{s})_{s \in \setop}, (\phi_{\Lambda_R})_{R
% \in \rho}, \phi_L)$ that, when interpreted in a structure $\mathcal{A}$ of
% size $n$, define a symmetric $(\BB_\setop, \rho)$-circuit with unique labels
% equivalent to $C_n$. We abuse notation and also refer to to this equivalent
% circuit as $C_n$. Let $t$ be the width of this interpretation. The formulas in
% $\Phi$ are defined as follows.

% \begin{myitemize}
% \item $\phi_G(\mu)$, when interpreted in $\mathcal{A}$, defines the set of
%   gates in the interpretation of the circuit as a subset of $[n]^t$. We
%   identify this set with $G$, and hence write $G \subseteq [n]^t$.
% \item $\phi_{\Omega}(\nu_1, \ldots , \nu_q, \mu)$ is defined such that
%   $\mathcal{A} \models \phi_\Omega[a_1, \ldots, a_q, g]$ if, and only if,
%   $(a_1, \ldots, a_q) \in [n]^q$ and $\Omega(a_1, \ldots, a_q) = g$.
% \item $\phi_s (\mu)$ is defined for $s \in \setop \uplus \rho \uplus \{0,1\}$
%   such that $\mathcal{A} \models \phi_s [g]$ if, and only if, $g$ is an input
%   gate and $\Sigma (g) = s$ or $g$ is an internal gate and $\Sigma$ maps $g$
%   to an element of $\mathcal{B}_{s}$.
% \item $\phi_{\setop_i} (\mu; \delta_1, \ldots, \delta_{l_i}; \epsilon_1,
%   \ldots, \epsilon_{m_i}; \kappa)$ is defined for $\setop_i \in \setop$ where
%   $l_i$ is the number of relation symbols in the vocabulary of $\setop_i$ and
%   $m_i$ is the parameter width of $\setop_i$ and is such that $\mathcal{A}
%   \models \phi_{\setop_i}[g; a_1, \ldots, a_{l_i}; p_1, \ldots, p_{m_i}; k_i]$
%   if, and only if, $g$ is a gate and $\Sigma (g) = F^X_{\Omega_i, \vec{p},
%   k_i}$, where $\vec{p} := (p_1, \ldots, p_{m_i})$ and $X := \uplus_{j \in
%   [l_i]} [a_{j}]$.
% \item For $R \in \rho$, let $r$ be the arity of $R$, and let
%   $\phi_{\Lambda_R}(\nu_1, \ldots, \nu_r, \mu)$ be defined such that
%   $\mathcal{A} \models \phi_{\Lambda_R} [a_1, \ldots, a_r, g]$ if, and only
%   if, $(a_1, \ldots, a_r) \in [n]^r$ and $g$ is a relational gate such that
%   $\Sigma (g) = R$ and $\Lambda_R (g) = (a_1, \ldots, a_r)$.
% \item $\phi_V (\mu, \delta, \epsilon_1, \epsilon_2)$ is defined such that
%   $\mathcal{A} \models \phi[g, R, i, r]$ if, and only if, $g$ is a gate, $R$
%   denotes the $i$th relation symbol in the vocabulary of $g$, and $r$ is the
%   arity of $R$.
% \item $\phi_L(\mu, \nu, \delta_1, \ldots, \delta_{\maxarity}, \epsilon)$ is
%   defined such that $\mathcal{A} \models \phi_L[g, h, x_1, \ldots,
%   x_{\maxarity}, R_{i}]$ if, and only if, $h$ is a gate and $g$ is an internal
%   gate, $R_i$ denotes the $i$th relation symbol in the vocabulary of $g$, and
%   $L(g)((x_1, \ldots, x_{r_i}), R_i) = h$, where $r_i$ is the arity of $R_i$.
% \end{myitemize}

% We should note that the interpretation $\Phi$ does not encode the circuit
% exactly as one might expect. In particular, there is no formula in $\Phi$
% corresponding to the function $\Sigma$ in $C_n$. Instead, we have included a
% family of formulas $(\phi_s)_{s \in T_{\rank} \uplus \rho \uplus \{0,1\}\}}$,
% where each $\phi_s$ defines the set of gates of type $s$, and the formula
% $\phi_{\rank}$, which defines the the set of rank gates with a given
% characteristic and threshold. It is easy to see that, along with $\phi_L$,
% these formulas suffice to define $\Sigma$.
  
% Let $n_0$ and $k$ be the constants in the statement of
% Lemma~\ref{lem:row-column-supports}. Notice that for each $n \leq n_0$, there
% are constantly many bijections from the universe of an $\rho$-structure
% $\mathcal{A}$ of size $n$ to $[n]$. As such there exists an $\FPC$ formula
% that evaluates $C_n$ for any $n \leq n_0$ by explicitly quantifying over all
% of these constantly many bijections, and then evaluating the circuit with
% respect to each bijection. As such we need only consider the case where $n >
% n_0$. In the rest of this subsection we let $\mathcal{A}$ denote a
% $\rho$-structure of size $n$.

% We should like to recursively construct $\EV_g$ for each gate $g$ in the
% circuit. However, while we have from Lemma~\ref{lem:row-column-supports} that
% the canonical support of $g$ has size at most $k$, it may not be exactly equal
% to $k$. As such, if $\vert \consp(g) \vert = \ell$, we define

% \begin{align*}
% 	\overline{\EV}_g = \{ (a_1, \ldots , a_k) \in [n]^k : (a_1 , \ldots , a_\ell ) \in \EV_g \text{ and } i \neq j \implies a_i \neq a_j \}. 
% \end{align*}

% In this subsection we use $\mu$ and $\nu$ to denote number variables that
% should be assigned to gates and use $\epsilon$ and $\delta$ to denote
% variables that should be assigned to elements of the universe of a gate. We
% use $\kappa$ and $\pi$ to denote other number variables. We use $x, y, z,
% \ldots$ to denote vertex variables and $U, V, \ldots$ to denote relational
% variables. We use $a, b, c , \ldots$ to denote elements of the vertex sort.
% When a vector of values or variables is used without reference to size, it is
% taken to be a $k$-tuple.

% Let $s \subseteq [n]$, $X$ be a set, and $f \in X^{\underline{s}}$. Then, as
% $[n]$, and hence $s$, is an ordered set, we let $\vec{s}$ denote the $\vert s
% \vert$-tuple given by listing the elements of $s$ in order. We let $\vec{f}$
% denote a $\vert s \vert$-tuple formed by applying $f$ to $s$ in order (i.e.\
% $\vec{f} := f \circ \vec{s}$).

% We seek to define the relation $V \subseteq [n]^t \times A^k$ in
% $\exFP{\Omega}$ such that $V(g, \vec{a})$ if, and only if, $\vec{a} \in
% \overline {\EV}_g$. We first construct an $\exFP{\Omega}$-formulas that
% recursively defines $\overline{\EV}_g$ for a given $g$ in $C_n$. We recall
% that, for a given $g$ in $C_n$, the recursive definition of $\overline{\EV}_g$
% depends on the type of the gate $g$. As such, we define for each possible type
% $s$ a formula $\theta_s(\mu, \vec{x})$ that defines $\overline{\EV}_g$ for a
% given $s$-gate $g$. We then take a disjunction over these formulas and, by an
% application of the fixed-point operator, define the $\FPR$-formula
% $\theta(\mu, \vec{x})$. We show that $\theta$ defines $V$.


% As mentioned above, $\theta_0$, $\theta_1$, $\theta_\AND$, $\theta_\OR$,
% $\theta_\NAND$, $\theta_\MAJ$ and $(\theta_R)_{R \in \tau}$ been defined by
% Anderson and Dawar~\cite{AndersonD17}. It remains for us to define an $\FPR$
% formula $\theta_{\RANK}(\mu, \vec{x})$ such that, if $\mu$ denotes a
% $\RANK$-gate $g$ and $\vec{x}$ denotes an assignment $\vec{a}$ to the support
% of $g$, $\theta_{\RANK}(\mu, \vec{x})$ corresponds to the recursive
% construction of $\EV_g$ presented in Section~\ref{sec:evaluating-circuits}. We
% first construct a formula $\psi_M$ that defines the matrix $M$, as given in
% the previous subsection, for a given gate and assignment to the support of
% that gate. We then define $\theta_{\RANK}$, which applies the rank operator to
% the matrix defined by $\psi_M$. In order to define $\psi_M$ and $\theta_\RANK$
% succinctly we first define a number of useful $\FPC$ formulas.

% We define the closed number terms $\FA{m} := (\# x (x = x))*t$ and $\FA{s} :=
% \# x(x = x)$, denoting the bound on the domain of $\Phi$ and the size of the
% structure over which we are working. We define two formulas that define the
% set of elements of the first and second sort of the universe of a gate $g$
% (i.e.\ the set of row and column indexes).


% \begin{align*}
%   \FA{max-col} (\mu, \epsilon, \delta) := \exists \nu 
% \end{align*}

% \begin{align*}
% 	\FA{row} (\mu, \delta) :=   & \exists \nu, \epsilon \leq \FA{m} \, (\Phi_L (\mu, \delta, \epsilon, \nu)) \\
% 	\FA{col} (\mu, \epsilon) := & \exists \nu, \delta \leq \FA{m} \, (\Phi_L (\mu, \nu, \delta , \epsilon))  
% \end{align*}
% From Lemma~\ref{lem:computing-support-orbit-index}, and invoking the
% Immerman-Vardi theorem, there exists an $\FPC$-formula $\FA{orb}(\mu, \delta,
% \epsilon)$ such that $\mathcal{A} \models \FA{orb}[g,i, i']$ if, and only if,
% $i$ and $i'$ are in the universe of $g$ and $i \in \orb(i')$. The following
% formula allows us to define the minimal element of this orbit
% \begin{align*}
% 	\FA{min-orb} (\mu, \delta) := \forall \epsilon \leq \FA{m} \, (\FA{orb} (\mu, \delta, \epsilon) \implies \delta \leq \epsilon). 
% \end{align*}

% From~\cite{AndersonD17} there is an $\FP^{\nats}$-formula $\FA{supp}$ such
% that $\mathcal{A} \models \FA{supp} [g, u]$ if, and only if, $\mathcal{A}
% \models \phi_G [g]$ and $u$ is in $\consp(g)$. In~\cite{AndersonD17} this
% formula is used to inductively define a set of formulas $\FA{supp}_i$ for each
% $i \in \nats$ such that $\mathcal{A} \models \FA{supp}_i[g, u]$ if, and only
% if, $u$ is the $i$th element of $\consp(g)$.

% Similarly, we can define $\FA{supp-voc} (\mu, \epsilon_1, \epsilon_2, \delta)$
% is such that $\mathcal{A} \models \FA{supp-voc}[g, a, j, u]$ if, and only if,
% $g$ is an internal gate, $a$ is an element of the $j$th sort of $g$, and $u$
% is in $\consp(a)$. For each $i \in \nats$ let $\FA{\supp-voc}_i (\mu,
% \epsilon_1, \epsilon_2, \delta)$ be such that $\mathcal{A} \models
% \FA{supp-voc}_i[g, a, j, u]$ if, and only if, $\mathcal{A} \models
% \FA{supp-voc}[g, a, j, u]$ and $u$ is the $i$th element of $\consp(a)$.

% From~\cite{AndersonD17} we have an $\FPC$ formula $\FA{agree}(\mu, \nu,
% \vec{x}, \vec{y})$ such that $\mathcal{A} \models \FA{agree}[g, h, \vec{a},
% \vec{b}]$ if, and only if, $\vec{a} \circ (\vec{\consp}(g))^{-1}$ is
% compatible with $\vec{b} \circ (\vec{\consp}(h))^{-1}$.

% A similar argument allows us to define $\FA{agree}_{L} (\mu, \delta , \vec{x},
% \vec{z})$ (where $\vec{z}$ is a tuple of size $2k$) such that $\mathcal{A}
% \models \FA{agree}_L [g, i, \vec{a}, \vec{r}]$ if, and only if,
% $\vec{a}_{\vec{\consp}(g)}$ and $\vec{r}_{\vec{\consp}(i)}$ are compatible.

% It can be shown that given a number $n$, a gate $g$ in $C_n$ and two pairs
% $(i, \vec{x}) \in I$ and $(j, \vec{y}) \in J$ the function $\vec{c}$ in
% Lemma~\ref{lem:permutation-row-column} can be computed in time polynomial in
% $n$. Thus, from the Immerman-Vardi Theorem, it can be defined by a number
% term. Thus we assert that there exists an $\FPC$ formula $\FA{move} (\mu,
% \delta, \epsilon, \vec{x}, \vec{y}, \vec{z}, \vec{w})$ (where $\vec{y}$ and
% $\vec{z}$ are $2k$-tuples) such that $\mathcal{A} \models \FA{move} [g, i, j,
% \vec{a}, \vec{b}, \vec{d}]$ if, and only if, $\mathcal{A} \models \phi_G [g]
% \land \FA{row}_g[g,i] \land \FA{col}[g, j]$ and $\mathcal{A} \models
% \FA{agree}_L [g, i, \vec{a}, \vec{b}] \land \FA{agree}_L [g, j, \vec{a},
% \vec{d}]$ and $\vec{d}_{\vec{\consp}(j)} = \vec{c}$, where $\vec{c}$ is the
% vector given in Lemma~\ref{lem:permutation-row-column} defined from the pairs
% $(i, \vec{a}_{\vec{\consp}(i)})$ and $(j, \vec{b}_{\vec{\consp}(j)})$.

% It is possible to define a polynomial-time algorithm that takes in a gate $g$
% and $j, j' \in \universe{g}$ and $\vec{c}$, a $2k$-tuple with values in $[n]$,
% constructs a permutation $\sigma \in \spstab{g}$ such that $\sigma
% (\vec{\consp}(j)) := \vec{c}$ and checks, using
% Lemma~\ref{lem:compute-automorphisms-labels}, if $\sigma j = j'$.

% It follows from the Immerman-Vardi theorem that there is an $\FPC$ formula
% $\FA{map}(\mu, \delta_1, \delta_2, \vec{z})$ (where $\vec{z}$ is a $2k$-tuple)
% such that $\mathcal{A} \models \FA{map}[g, j, j', \vec{c}]$ if, and only if,
% $\mathcal{A} \models \phi_G [g] \land \FA{col}[g, j] \land \FA{col}[g, j']$
% and such that there exists $\sigma \in \spstab{g}$ where $\sigma
% (\vec{\consp}(j)) = \vec{c}$ and $\sigma j = j'$.
				
% We now define an $\FPC$-formula $\FA{merge}$ such that $\mathcal{A} \models
% \FA{merge}[g, h, \vec{a}, \vec{b}, \vec{r}, \vec{c}]$ if, and only if, (i) $g$
% and $h$ are gates such that $h \in H_g$, (ii) $\vec{a}$ and $\vec{b}$ are
% $k$-tuples in $[n]$ and $\vec{r}$ and $\vec{c}$ are $2k$-tuples in $[n]$, and
% (iii) $\vec{a}_{\vec{\consp}(h)}$, $\vec{b}_{\vec{\consp}(h)}$,
% $\vec{r}_{\vec{\consp}(i)}$, and $\vec{c}_{\vec{\consp}(j)}$ (where $i := \row
% (h)$ and $j := \column (j)$) are all compatible with one another. We note that
% $\vec{w}_1$ and $\vec{w}_2$ are $2k$-tuples of variables. Let
% \begin{align*}
% 	\FA{merge} (\mu, \nu, \vec{x}, \vec{y}, \vec{w}_1, \vec{w}_2) := & \exists \delta, \epsilon \leq \FA{m} \, ( \phi_L (\mu, \nu, \delta, \epsilon) \\ & \land \FA{agree}_L (\mu, \nu , \delta, \vec{x}, \vec{y}, \vec{w}_1) \land \\ & \FA{agree}_L (\mu, \nu , \epsilon, \vec{x}, \vec{y}, \vec{w}_2)).
% \end{align*}
% We are almost ready to define the matrix $M$ from the previous subsection. We
% break this up into two formulas. The first is used to to check if an index is
% in the domain of the matrix and the second defines $M$ for a given index. We
% note that $\vec{y}$ and $\vec{z}$ are $2k$-tuples in the below formulas and
% let $\FA{dom}_{\phi_L} (\mu, \delta, \epsilon) := \exists \nu \leq \FA{m} \,
% \phi_L (\mu, \nu, \delta, \epsilon)$. Let
				
% \begin{align*}
% 	\FA{check-dom}(\mu, \vec{x}, \delta, \vec{y}, \epsilon, \vec{z})  := & \FA{dom}_{\phi_L} (\mu, \delta, \epsilon) \land \FA{min-orb}(\mu, \delta)\land \FA{min-orb} (\mu, \epsilon) \\ & \land \FA{agree}_L (\mu, \delta , \vec{x}, \vec{y}) \land \FA{agree}_L (\mu, \epsilon , \vec{x}, \vec{z}), 
% \end{align*}
% and
% \begin{align*}
% 	\FA{find-eval} (\mu, \vec{x}, \delta, \vec{y}, \epsilon, \vec{z}) := & \exists \vec{s} \leq \FA{s} \, (\FA{move}(\mu, \delta, \epsilon, \vec{x}, \vec{y}, \vec{z}, \vec{s}) \\ & \land (\exists \epsilon' \leq \FA{m} \, (\FA{map}^c (\mu, \epsilon, \epsilon', \vec{s}) \land (\exists \nu \leq \FA{m} \, (\phi_L (\mu, \delta, \epsilon', \nu) \\ & \land (\exists \vec{m} \, \leq \FA{s} \, (\FA{merge} (\mu, \nu, \vec{x}, \vec{m}, \vec{y}, \vec{z}) \land V(\nu, \vec{m})))))))).
% \end{align*}
				
% We are now ready to define the formula that defines the matrix $M$ for a given
% gate and assignment to the support of $g$. Let


% \begin{align*}
%   \psi^D_i (\delta, \vec{x}) := ....
% \end{align*}

% \begin{align*}
%   \psi^{\equiv}_i ((\delta, \vec{x}), (\epsilon, \vec{y})) := (\delta = \epsilon) \land (\bigvee_{\vec{a} \in D(\vec{x}, \vec{y})})
% \end{align*}

% \begin{align*}
% 	\psi_M (\mu, \vec{x}, \delta, \vec{x}, \epsilon, \vec{y}) :=  \FA{check-dom}(\mu, \vec{x}, \delta, \vec{y}, \epsilon, \vec{z}) \land \FA{find-eval} (\mu, \vec{x}, \delta, \vec{y}, \epsilon, \vec{z}).
% \end{align*}
				
% We now define the formula that evaluates the $\RANK$-gate $g$. Let

% \begin{align*}
%   \psi_\equiv ((\epsilon_1, \vec{x}_1), \ldots, (\epsilon_{r}, \vec{x}_r)) ((\delta_1, \vec{y}_1), \ldots, (\delta_{r}, \vec{y}_r)) := \bigwedge_{i \in [r]} [(\delta_i = \epsilon_i) \land ((\bigvee_{\vec{a} \in [n]}\FA{action} (\delta_i, \epsilon_i \vec{a}))
% \end{align*}
				
% \begin{align*}
% 	\theta_\RANK (\mu, \vec{x}) := & \bigwedge_{1 \leq i < j \leq k} x_i \neq x_j \land (\exists \pi, \kappa \leq \FA{m} \, (\phi_{\rank}(\mu, \pi, \kappa) \\ &\land [\rank (\vec{y}\delta\leq \FA{m}, \vec{z}\epsilon\leq \FA{m}, \pi \leq \FA{m}). \psi_M] \leq \kappa ))).
% \end{align*}

% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
% ------------------------------------------------------------------------------------------------------------------------------
Let $\setop := \{\setop_1, \ldots, \setop_w\}$, where for each $i \in [w]$,
$\setop_i$ is a uniform operator that acts on formulas. Let $\BB := \BB_{\setop}
\uplus \BS$. Let $R(\BB)$ be the set of all relation symbols that appear in the
vocabulary of a function in $\BB$. Let $\rho$ be a relational vocabulary. Let
$\mathcal{C} := (C_n)_{n \in \mathbb{N}}$ be a fixed $\PT$-uniform family of
transparent symmetric $(\BB, \rho)$-circuits, and suppose $\mathcal{C}$ defines
a $q$-ary query. For each $n \in \nats$ let $C_n := (G_n, \Omega_n, \Sigma_n,
\Lambda_n, L_n)$.

In this section we aim to define a $\exFP{\setop}[\rho]$-formula $Q$ such that
$\mathcal{C}$ and $Q$ define the same query. The overall approach for
constructing $Q$ is as follows. First, we note that, from the Immerman-Vardi
theorem, there exists a $\natFP[\rho]$-interpretation that defines a family of
symmetric circuits with unique labels equivalent to $\mathcal{C}$. Second, we
show that it is possible to recursively define $\EV_g$ for each gate $g$ in the
circuit. Third, we use the fixed-point operator to complete this recursive
definition, and, we define $Q$ by evaluating the output gates of the circuit.

Let $T := \{\AND, \OR, \NAND\} \cup \setop \cup \rho \cup \{0,1\}$. It follows
from the Immerman-Vardi theorem~\cite{Immerman198686, Vardi:1982}, the
$\PT$-uniformity of $\mathcal{C}$, and Lemma~\ref{lem:transparent-unique}, that
there is an $\natFP[\rho]$-interpretation
\begin{align*}
  \Phi := (\phi_G,
  \phi_\Omega, (\phi_{\Sigma, s})_{ s \in T},
  (\phi_{\setop_i})_{\setop_i \in \setop}, (\phi_{\Lambda_R})_{R \in \rho},
  (\phi_{L, R_i})_{R_i \in R(\BB)})
\end{align*}
such that for each $n \in \nats$ when $\Phi$ is interpreted in $\rho$-structure
$\mathcal{A}$ of size $n$ it defines a symmetric $(\BB, \rho)$-circuit with
unique labels equivalent to $C_n$ in the number domain. We abuse notation and
also refer to this equivalent circuit as $C_n$. Let $t$ be the width of this
interpretation. Throughout this section we use $\mu$, $\nu$, $\epsilon$, $\eta$,
and $\delta$ to denote $t$-length sequences of number variables and $\kappa$ and
$\pi$ to denote individual number variables. We now describe the formulas in
$\Phi$ by describing the relation that each formula defines when interpreted in
a $\rho$-structure $\mathcal{A}$ of size $n$.

\begin{myitemize}
\item $\phi_G(\mu)$ defines the set of gates in the circuit $C_n$ as a subset of
  $[n]^t$. We identify this set with $G_n$, and hence write $G_n \subseteq
  [n]^t$.
\item $\phi_{\Omega}(\kappa_1, \ldots , \kappa_q, \mu)$ is defined such that
  $\mathcal{A} \models \phi_\Omega[a_1, \ldots, a_q, g]$ if, and only if, $(a_1,
  \ldots, a_q) \in [n]^q$ and $\Omega_n(a_1, \ldots, a_q) = g$.
\item $\phi_{\Sigma, s} (\mu)$ is defined for $s \in T$ such that $\mathcal{A}
  \models \phi_s [g]$ if, and only if, $g$ is an input gate and $\Sigma_n (g) =
  s$ or $g$ is an internal gate and $\Sigma_n$ maps $g$ to an element of
  $\mathcal{B}_{s}$.
\item Let $\setop_i \in \setop$. Let $l_i$ be the number of sorts in the
  vocabulary of $\setop_i$ and let $m_i$ be the parameter width of $\setop_i$.
  Then $\phi_{\setop_i} (\mu, \delta_1, \ldots, \delta_{m_i}, \epsilon)$ is such
  that $\mathcal{A} \models \phi_{\setop_i}[g, p_1, \ldots, p_{m_i}, k_i]$ if,
  and only if, $g$ is a gate, $p_1, \ldots, p_{m_i}, k_i \in \nats$, and
  $\Sigma_n (g) = F^{k_i}_{\setop_i, (p_1, \ldots, p_{m_i})}[a_1, \ldots, a_j]$,
  for some $a_1, \ldots a_j \in \nats$.
\item Let $R \in \rho$. Let $r$ be the arity of $R$. Then $\phi_{\Lambda_R}(\mu,
  \delta_1, \ldots, \delta_r)$ is such that $\mathcal{A} \models
  \phi_{\Lambda_R} [g, a_1, \ldots, a_r]$ if, and only if, $(a_1, \ldots, a_r)
  \in [n]^r$ and $g$ is a relational gate such that $\Sigma (g) = R$ and
  $(\Lambda_n)_R (g) = (a_1, \ldots, a_r)$.
\item Let $R_i \in R(\BB)$. Let $r_i$ be the arity of $R_i$. Then $\phi_{L,
    R_i}(\mu, \nu, \delta_1, \ldots, \delta_{r_i})$ is such that $\mathcal{A}
  \models \phi_{L, R_i}[g, h, a_1, \ldots, a_{r_i}]$ if, and only if, $g$ is an
  internal gate such that $R_i$ is a relation symbol in the vocabulary of
  $\Sigma_n(g)$, $h \in H_g$, and $L_n(g)((a_1, \ldots, a_{r_i}), R_i) = h$.
\end{myitemize}

The interpretation $\Phi$ does not define a circuit in exactly the way we might
expect. In particular, there is no single formula in $\Phi$ that defines, for $n
\in \nats$, $\Sigma_n$ or $L_n$. Instead, $\Phi$ includes three families of
formulas $(\phi_{\Sigma, s})_{ s \in T}$, $(\phi_{\setop_i})_{\setop_i \in
  \setop}$, and $(\phi_{L, R_i})_{R_i \in R(\BB)})$ which together suffice to
determine both of these functions.

Let $n_0$ and $k$ be the constants in the statement of
Lemma~\ref{lem:row-column-supports}. Let $r'$ be the maximal arity of a relation
in $R(\BB)$ and let $n_1 = \max(n_0, k \cdot (r' + 1))$. Notice that for each $n
\leq n_1$, there are constantly many bijections from the universe of an
$\rho$-structure $\mathcal{A}$ of size $n$ to $[n]$. As such there exists a
$\natFP$-formula that evaluates $C_n$ for any $n \leq n_1$ by explicitly
quantifying over all of these constantly many bijections, and then evaluating
the circuit with respect to each bijection. As such, we only need to consider
the case where $n > n_1$. For the rest of this section we fix such an $n > n_1$
and let $\mathcal{A}$ denote a $\rho$-structure of size $n$.

In the remainder of this section we use $\mu$ and $\nu$ to denote gates and
$\delta$ and $\epsilon$ to denote elements of the universe of a gate. We use
$\kappa$, $\pi$ and $\lambda$ to denote single number variables and
$\vec{\kappa}$ to denote a $2k$-length tuple of number variables. We use
$\vec{x}$ and $\vec{y}$ to denote $k$-length sequences of vertex variables and
use $\vec{z}$ to denote $2k$-length sequences of vertex variables. We use $U$
and $V$ to denote second-order variables. If $S$ is a subset of an ordered set
we write $\vec{S}$ to denote the $\vert S \vert$-tuple given by listing the
elements of $S$ in order. Let $X$ and $Y$ be sets, $\vec{a}$ be a sequence in
$X$, and $\vec{u}$ be a sequence of distinct elements in $Y$ such that $\vert
\vec{u} \vert \leq \vert \vec{a} \vert$. Let $\alpha^{\vec{u}}_{\vec{a}}: \img
(\vec{u}) \ra X$ be such that $\alpha^{\vec{u}}_{\vec{a}}(b) := \vec{a} \circ
\vec{u}^{-1}(b)$ for all $b \in \img(u)$.

We should like to recursively construct $\EV_g$ for each gate $g$ in the
circuit. However, while we have from Lemma~\ref{lem:row-column-supports} that
the canonical support of $g$ has size at most $k$, it may not be exactly equal
to $k$. As such, if $\vert \consp(g) \vert = \ell$, we define
\begin{align*}
	\overline{\EV}_g = \{ (a_1, \ldots , a_k) \in [n]^k : \alpha^{(a_1 , \ldots , a_\ell)}_{\vec{\consp}(g)} \in \EV_g \text{ and } i \neq j \implies a_i \neq a_j \}. 
\end{align*}

We aim to define a $\exFP{\setop}[\rho]$-formula $\theta(\mu, \vec{x})$ such
that $\mathcal{A} \models \theta[g, \vec{a}]$ if, and only if, $\vec{a} \in
\overline{\EV}_g$. We do so by defining for each $s \in T$ a formula $\theta_s$
that gives a recursive definition of $\theta$ for any gate associated with the
symbol $s$. We now state this formally. Let $V$ be a second-order variable with
the same type as $(\mu, \vec{x})$. We aim to define for each $s \in T$ a formula
$\theta_s$ so that for each gate $g$ with $\mathcal{A} \models \phi_{\Sigma,
  s}[g]$ and each $\vec{a} \in A^k$, if $V$ is mapped to a relation $\beta(V)$
such that all $h \in H_g$, $(h, \vec{b}) \in \beta(V)$, if, and only if,
$\vec{b} \in \overline{\EV}_g$, then $\mathcal{A} \models \theta_s [g, \vec{a};
\beta(V)]$ if, and only if, $\vec{a} \in \overline{\EV}_g$.
% We seek to define the relation $V \subseteq [n]^t \times A^k$ in
% $\exFP{\Omega}$ such that $V(g, \vec{a})$ if, and only if, $\vec{a} \in
% \overline {\EV}_g$. We first construct an $\exFP{\Omega}$-formulas that
% recursively defines $\overline{\EV}_g$ for a given $g$ in $C_n$. We recall
% that, for a given $g$ in $C_n$, the recursive definition of $\overline{\EV}_g$
% depends on the type of the gate $g$. As such, we define for each possible type
% $s$ a formula $\theta_s(\mu, \vec{x})$ that defines $\overline{\EV}_g$ for a
% given $s$-gate $g$. We then take a disjunction over these formulas and, by an
% application of the fixed-point operator, define the $\FPR$-formula
% $\theta(\mu, \vec{x})$. We show that $\theta$ defines $V$.

Anderson and Dawar~\cite{AndersonD17} have already defined $\theta_s$ for each
$s \in T \setminus \setop$. In each of these case the definition of $\theta_s$
is very straight-forward, and so we reproduce these formulas below with minimal
discussion (and minor adjustments). We first introduce a few auxiliary formulas.
We have from the Immerman-Vardi theorem and
Lemma~\ref{lem:computing-support-orbit-gate} that there exists a
$\natFP$-formula $\FA{supp}(\mu, \kappa)$ such that $\mathcal{A} \models
\FA{supp} [g, u]$ if, and only if, $g$ is a gate and $u \in \consp(g)$~\cite{AndersonD17}. We can
define from $\FA{supp}$ a formula $\FA{supp}_i$ for each $i \in \nats$ such that
$\mathcal{A} \models \FA{supp}_i[g, u]$ if, and only if, $u$ is the $i$th
element of $\consp(g)$. We define these formulas by induction as follows
\begin{align*}
  \FA{supp}_1(\mu, \kappa) &:= \FA{supp}(\mu, \kappa) \land (\forall \, \pi (\pi < \kappa) \implies \neg \FA{supp}(\mu, \pi)) \\
  \FA{supp}_{i + 1} (\mu, \kappa) &:= \FA{supp} (\mu, \kappa) \land \exists \pi_1 (\pi_1 < \kappa \land \FA{supp}_i(\mu, \pi_1) \\
                           & \land \forall \pi_2 ((\pi_1 < \pi_2 < \kappa) \implies \neg \FA{supp}(\mu, \pi_2))).
\end{align*}

We can define from these formulas a formula $\FA{agree}(\mu, \nu, \vec{x},
\vec{y})$ such that $\mathcal{A} \models \FA{agree}(g, h, \vec{a}, \vec{b})$ if,
and only if, $g$ and $h$ are gates, $h \in H_g$, and
$\alpha^{\vec{a}}_{\vec{\consp}(g)} \sim \alpha^{\vec{b}}_{\vec{\consp}(h)}$~\cite{AndersonD17}. We
define this formula as follows
\begin{align*}
  \FA{agree} (\mu, \nu, \vec{x}, \vec{y}) := \, & \phi_G(\mu) \land \phi_G(\nu) \land \bigwedge_{1 \leq e , d \leq [k]} [\forall \delta \, (\FA{supp}_e(\mu, \delta) \land \FA{supp}_d (\nu, \delta)) \implies x_e = y_d) \land \\
                                                &\forall \delta_1, \delta_2\, ((\FA{supp}_e (\mu, \delta_1) \land \FA{supp}_d (\mu, \delta_2) \land x_e = x_d) \implies \delta_1 = \delta_2)]
\end{align*}

Let $\phi_W(\nu, \mu) := \bigvee_{R_i \in R(\BB)} (\exists \delta_1, \ldots,
\delta_{r_i}. \, \phi_{L, R_i}(\mu, \nu, \delta_1, \ldots, \delta_{r_i}))$. It
can be seen that $\mathcal{A} \models \phi_W [h, g]$ if, and only if, $g$ is an
internal gate and $h \in H_g$. We now define for each $s \in T \setminus \setop$
a formula $\theta_s$ as follows
\begin{align*}
  \theta_0 (\mu, \vec{x}) &:= \exists y \, (y \neq y)\\
  \theta_1 (\mu, \vec{x}) &:= \bigwedge_{1 \leq i < j \leq k} x_i \neq x_j \\
  \theta_R (\mu, \vec{x}) &:= (\bigwedge_{1 \leq i < j \leq k} x_i \neq x_j) \land \exists y_1, \ldots, y_r \exists \kappa_1, \ldots, \kappa_r \, R(y_1, \ldots, y_r) \land  \phi_{\Lambda_R}(\mu, \kappa_1, \ldots, \kappa_{r}) \land \\ & \qquad {}   \bigwedge_{i \in [r]} \bigwedge_{j \in [k]} (\FA{supp}_j (\mu, \kappa_i) \implies y_i = x_j)\\
  \theta_{\OR} (\mu, \vec{x}) &:= (\bigwedge_{1 \leq i < j \leq k} x_i \neq x_j) \land \exists \nu \exists \vec{y}  \, \psi_{W} (\nu, \mu) \land \FA{agree}(\mu, \nu, \vec{x}, \vec{y}) \land V(\nu, \vec{y})\\
  \theta_{\AND} (\mu, \vec{x}) &:= (\bigwedge_{1 \leq i < j \leq k} x_i \neq x_j) \land \forall \nu \forall \vec{y} \, ((\psi_{W} (\nu, \mu) \land \FA{agree}(\mu, \nu, \vec{x}, \vec{y})) \implies V(\nu, \vec{y}))\\
  \theta_{\NAND} (\mu, \vec{x}) &:= (\bigwedge_{1 \leq i < j \leq k} x_i \neq x_j) \land \exists \nu \exists \vec{y}  \, \psi_{W} (\nu, \mu) \land \FA{agree}(\mu, \nu, \vec{x}, \vec{y}) \land \neg V(\nu, \vec{y})
\end{align*}

Let $\setop_f \in \setop$. We aim to define $\theta_{\setop_f}$. Let $\tau :=
(R, S, \zeta)$ be the vocabulary of $\setop_f$. Let $\{R_1, \ldots, R_r\} := R$
and let $\{s_1, \ldots, s_l\} := S$. For each $i \in [r]$ let $r_i$ be the arity
of $R_i$ and for each $j \in [r_i]$ and $p \in [l]$ let $c(i, j)$ be defined
such that $c(i, j) = p$ if, and only if, $s_p = \zeta(R_i)(j)$.

We have defined formulas that define the support of a gate and that express that
two assignments to the supports of two gates are compatible. We now define
analogous formulas for the supports of elements of the universe of a gate. Let
$j \in [l]$. From the Immerman-Vardi theorem and
Lemma~\ref{lem:computing-support-orbit-index} there is a formula
$\FA{supp}^j(\mu, \delta, \kappa)$ such that $\mathcal{A} \models \FA{supp}^j[g,
b, u]$ if, and only if, $g$ is a gate, $b$ is in $j$th sort of the universe of
$g$, and $u \in \consp_{\consp(g)}(b)$. We can define for each $i \in \nats$,
using a similar approach as for $\FA{supp}$, a formula $\FA{supp}^j_i(\mu,
\delta, \kappa)$ such that $\mathcal{A} \models \FA{supp}^j_i[g, u, m]$ if, and
only if, $\mathcal{A} \models \FA{supp}^j[g, u, m]$ and $m$ is the $i$th element
of $\consp_{\consp(g)}(u)$. We can use a similar approach as in the definition
$\FA{agree}$ to define for each $j \in [l]$ a formula $\FA{agree}^j_L (\mu, \nu,
\delta, \vec{x}, \vec{y}, \vec{z})$ such that $\mathcal{A} \models
\FA{agree}^j_L [g, h, u, \vec{a}, \vec{b}, \vec{c}]$ if, and only if, $g$ and
$h$ are gates with $h \in H_g$, $u$ is in the $j$th sort of the universe of $g$,
and $\alpha^{\vec{a}}_{\vec{\consp}(g)}$, $\alpha^{\vec{b}}_{\vec{\consp}(h)}$,
and $\alpha^{\vec{c}}_{\vec{\consp}(u)}$ are all pairwise compatible. Let
$\FA{agree}^j_L(\mu, \delta, \vec{x}, \vec{z}) := \exists \nu \vec{y}. \,
\FA{agree}^j_L (\mu, \nu, \delta, \vec{x}, \vec{y}, \vec{z})$.

We have from Lemma~\ref{lem:compute-automorphisms-labels} and the Immerman-Vardi
theorem that there is a formula $\FA{move}^j(\mu, \delta_1, \delta_2,
\vec{\kappa})$ such that such that $\mathcal{A} \models \FA{move}^j[g, b_1, b_2,
\vec{u}]$ if, and only if, $g$ is a gate, $b_1$ and $b_2$ are elements of the
$j$th sort of $g$, for all $a, b \in [2k]$ if $a \neq b$ then $u_a \neq u_b$,
and there exists $\sigma \in \spstab{g}$ such that for all $a \in [\vert
\consp(b_1) \vert]$, $\sigma (\vec{\consp}(b_1)(a)) = u_a$ and $\sigma (b_1) =
b_2$. In other words, $\mathcal{A} \models \FA{move}^j[g, b_1, b_2, \vec{u}]$
if, and only if, the function that maps the support of $b_1$ to $\vec{u}$
extends to a permutation in $\spstab{g}$ that maps $b_1$ to $b_2$.

Let $\FA{orb}^j(\mu, \delta_1, \delta_2) := \exists \vec{\kappa} . \,
\FA{move}^j(\mu, \delta_1, \delta_2, \vec{\kappa})$. It can be seen that
$\mathcal{A} \models \FA{orb}^j [g, b_1, b_2]$ if, and only if, $b_1$ and $b_2$
are elements of the $j$th sort of $g$ and $b_1 \in \orb(b_2)$. Let
\begin{align*}
  \FA{min-orb}^j (\mu, \delta) := \forall \epsilon \, (\FA{orb}^j (\mu, \delta, \epsilon) \implies \delta \leq \epsilon). 
\end{align*}

The can use a similar approach as in the definition of $\FA{supp}_i$ in order to
define for each $i \in \nats$ and $j \in [l]$ the formulas $\FA{out-sp}_i (\mu,
\lambda)$ and $\FA{out-sp}^j_i(\mu, \delta, \lambda)$ such that $\mathcal{A}
\models \FA{out-sp}[g, m]$ if, and only if, $g$ is a gate and $m$ is the $i$th
element of $[n] \setminus \consp(g)$ and $\mathcal{A} \models \FA{in-sp}^j_i[g,
u, m]$ if, and only if, $g$ is an internal gate, $u$ is in the $j$th sort of the
universe of $g$, and $m$ is the $i$th element of $\consp_{\consp(g)}(u)$.

In Section~\ref{sec:evaluating-circuits} we defined for each gate $g$ and $\eta
\in A^{\underline{\consp(g)}}$ a structure $M^{g, \eta}_\equiv$. We aim to show
that we can define this structure in $\natFP[\rho]$. We constructed $M^{g,
  \eta}_\equiv$ in stages as follows. First, we defined the functions
$\bar{J}^{g, \eta}$ and $J^{g, \eta}$, second, we defined the structure $M^{g,
  \eta}$, third, we defined the mutual stability relation, and fourth, we
defined $M^{g, \eta}_{\equiv}$ by taking a quotient of $M^{g, \eta}$. In order
to define $M^{g, \eta}_\equiv$ in $\natFP[\rho]$ we first define formulas
corresponding to each of these stages.

Let $R_i \in R$. We aim to define a formula $\psi_{\bar{J}, R_i} (\mu, \vec{x},
\delta_{1}, \vec{z}_1, \ldots, \delta_{r_i}, \vec{z}_{r_i}, \vec{\kappa}_1,
\ldots, \vec{\kappa}_{r_i})$ such that $\mathcal{A} \models \psi_{\bar{J}, R_i}
[g, \vec{a}, u_1, \vec{c}_1, \ldots, u_{r_i}, \vec{c}_{r_i}, \vec{m}_1, \ldots,
\vec{m}_{r_i}]$ if, and only if, $g$ is a gate, for each $j \in [r_i]$ we have
that $u_i$ is an element of the $c(i, j)$th sort in the universe of $g$, and
$\bar{J}^{g, \alpha^{\vec{a}}_{\vec{\consp}(g)}} ( (u_1,
\alpha^{\vec{c}_1}_{\vec{\consp}(u_1)}), \ldots, (u_{r_i},
\alpha^{\vec{c}_{r_i}}_{\vec{\consp}(u_{r_i})})) =
(\alpha^{\vec{m}_1}_{\vec{\consp}(u_1)}, \ldots,
\alpha^{\vec{m}_{r_i}}_{\vec{\consp}(u_{r_i})})$. We define this formula
recursively. We first define a set of auxiliary formulas. For each $p \in \nats$
and $j \in [2k]$ let
% \begin{align*}
%   \psi_{R_i, p}(\mu, \vec{x}, \delta, \vec{z}, \vec{\kappa}) :=  & \bigwedge_{1 \leq a < b \leq k} (x_a \neq x_b) \land \bigwedge_{1 \leq a < b \leq 2k}(z_a \neq z_b \land \kappa_a \neq \kappa_b) \land \FA{agree}^{c(i, p)}(\mu,\delta, \vec{x}, \vec{z}) \land \\
%                                                                  &\bigwedge_{j \in [2k]}  [\, (\forall \lambda .\, \neg \FA{supp}^{c(i, p)}_j(\mu, \delta, \lambda)) \lor \exists \lambda . \, [ \FA{supp}^{c(i, p)}_j(\mu, \delta, \lambda)  \land   [(\FA{supp}(\mu, \lambda) \land \vec{\kappa} (j) = \lambda) \lor \\ & (\neg \FA{supp}(\mu, \lambda) \land   \bigvee_{a \in [2k]} \FA{in-sp}^{c(i, p)}_a (\mu, \delta, \lambda) \land \FA{out-sp}_{(p-1)k + a} (\mu, \vec{\kappa}(j)))]]].
% \end{align*}
\begin{align*}
  \psi^j_{R_i, p}(\mu, \vec{x}, \delta, \vec{z}, \vec{\kappa}) :=  & (\forall \lambda .\, \neg \FA{supp}^{c(i, p)}_j(\mu, \delta, \lambda)) \lor \exists \lambda . \, [ \FA{supp}^{c(i, p)}_j(\mu, \delta, \lambda)  \land   [(\FA{supp}(\mu, \lambda) \land \vec{\kappa} (j) = \lambda) \lor \\ & (\neg \FA{supp}(\mu, \lambda) \land   \bigvee_{a \in [2k]} \FA{in-sp}^{c(i, p)}_a (\mu, \delta, \lambda) \land \FA{out-sp}_{(p-1)k + a} (\mu, \vec{\kappa}(j)))]].
\end{align*}
This formula will be used to deal with two case that appear both in the base
case and in the inductive case in the definition of $\bar{J}^{g, \eta}$. The
sequence $\vec{\kappa}$ is intended to encode a function that maps the support
of $\delta$ to $\vec{\kappa}$. The purpose of this formula is to check if there
is some element $u$ that is the $j$th element of the support of $\delta$ and, if
there is, to check that (i) if $u$ is in the support of $\mu$ then the function
encoded by $\vec{\kappa}$ fixes $u$, and (ii) if $u$ is not in the support of
$\mu$ then the function encoded by $\vec{\kappa}$ maps $u$ to an appropriate
element outside the support of $\mu$. We now define for each $p \in [r_i]$ a
$\natFP$-formula $\psi^p_{\bar{J}, R_i}$ as follows. Let
% The purpose of the first line of this formula is to check that the assignments
% to the supports of $\mu$ and $\delta$, and the permutation encoded by
% $\vec{\kappa}$, are injections and the assignments to $\mu$ and $\delta$ are
% compatible. The purpose of the second line is to check that the permutation
% encoded by $\vec{\kappa}$ fixes those elements in the supports of both
% $\delta$ and $\mu$. The purpose of the third line is to check that
% $\vec{\kappa}$ maps those elements in the support of $\delta$ that are not in
% the support of $\mu$ to appropriate elements outside the support of $\mu$.
\begin{align*}
  \psi^1_{\bar{J}, R_i} (\mu, \vec{x}, \delta_1, \vec{z}_1, \vec{\kappa}_1) := & \bigwedge_{1 \leq a < b \leq k} (x_a \neq x_b) \land \bigwedge_{1 \leq a < b \leq 2k}(z_a \neq z_b \land \kappa_a \neq \kappa_b) \land \\ & \FA{agree}^{c(i, p)}_L(\mu,\delta, \vec{x}, \vec{z}) \land \bigwedge_{j \in [2k]} \psi^j_{R_i, 1}(\mu, \vec{x}, \delta_1, \vec{z}_1, \vec{\kappa}_1),
\end{align*}
% \begin{align*}
%   \psi^1_{\bar{J}, R_i} (\mu, \vec{x}, \delta_1, \vec{z}_1, \vec{\kappa}_1) := \psi_{R_i, 1}(\mu, \vec{x}, \delta_1, \vec{z}_1, \vec{\kappa}_1),
% \end{align*}
and let
\begin{align*}
  \psi^{p+1}_{\bar{J}, R_i} (\mu, \vec{x}, \delta_{1}, \vec{z}_1, &\ldots, \delta_{p+1}, \vec{z}_{p+1}, \vec{\kappa}_1, \ldots, \vec{\kappa}_{p+1}) :=  \psi^{p}_{\bar{J}, R_i} (\mu, \vec{x}, \delta_{1}, \vec{z}_1, \ldots, \delta_{p}, \vec{z}_{p}, \vec{\kappa}_1, \ldots, \vec{\kappa}_{p})  \land \\ &  \bigwedge_{1 \leq a < b \leq 2k}(\vec{z}_{p+1}(a) \neq \vec{z}_{p+1}(b) \land \vec{\kappa}_{p +1}(a) \neq \vec{\kappa}_{p +1} (b)) \land \FA{agree}^{c(i, p+1)}_L(\mu, \delta_{p+1}, \vec{x}, \vec{z}_{p + 1})\land \\ & \bigwedge_{b \in [2k]} [(\exists \lambda \, \, \FA{supp}^{c(i, p+1)}_b(g, \delta_{p+1}, \lambda)) \implies  [[(\bigwedge_{a \in [p]} \bigwedge_{d \in [2k]} [(\exists \lambda_1 \FA{supp}^{c(i, j)}_d(g, \delta_{a}, \lambda_1)) \implies \\ & \vec{z}_{p+1}(b) \neq \vec{z}_{a}(d)]) \land \psi^b_{R_i, p+1}(\mu, \vec{x}, \delta_{p+1}, \vec{z}_{p+1}, \vec{\kappa}_{p+1})] \lor  \\ & [\bigvee_{a \in [p]} \bigvee_{d \in [2k]} (\exists \lambda_1 \FA{supp}^{c(i, j)}_d(g, \delta_{a}, \lambda_1))) \land \vec{z}_{p+1}(b) = \vec{z}_{a}(d) \land \vec{\kappa}_{p+1}(b) = \vec{\kappa}_{a}(d))]]]
  % [\exists \lambda_1, \lambda_2 (\FA{supp}^{c(i, j)}_b(g, \delta_{p+1},
  % \lambda_1) \land \FA{supp}^{c(i, j)}_d(g, \delta_{a}, \lambda_2))] \implies
  % \vec{z}_{p+1}(b) \neq \vec{z}_{a}(d)) \land \\ &\psi_{R_i, p+1}(\mu,
  % \vec{x}, \delta_{p+1}, \vec{z}_{p+1}, \vec{\kappa}_{p+1})] \lor [\bigvee_{a
  % \in [p]} \bigvee_{b \in [2k]}\bigvee_{d \in [2k]} [\exists \lambda_1,
  % \lambda_2 (\FA{supp}^{c(i, j)}_b(g, \delta_{p+1}, \lambda_1) \land \\ &
  % \FA{supp}^{c(i, j)}_d(g, \delta_{a}, \lambda_2))] \land \vec{z}_{p+1}(b) =
  % \vec{z}_{a}(d) \land \vec{\kappa}_{p+1}(b) = \vec{\kappa}_{a}(d))]].
\end{align*}
% \psi^{p+1}_{\bar{J}, R_i} (\mu, \vec{x}, \delta_{1}, \vec{z}_1, &\ldots,
% \delta_{p+1}, \vec{z}_{p+1}, \vec{\kappa}_1, \ldots, \vec{\kappa}_{p+1}) :=
% \psi^{p}_{\bar{J}, R_i} (\mu, \vec{x}, \delta_{1}, \vec{z}_1, \ldots,
% \delta_{p}, \vec{z}_{p}, \vec{\kappa}_1, \ldots, \vec{\kappa}_{p}) \land \\ &
% \bigwedge_{1 \leq a < b \leq 2k}(\vec{z}_{p+1}(a) \neq \vec{z}_{p+1}(b) \land
% \vec{\kappa}_{p +1}(a) \neq \vec{\kappa}_{p +1} (b)) \land \FA{agree}^{c(i,
% p+1)}(\mu, \delta_{p+1}, \vec{x}, \vec{z}_{p + 1})\land \\ & \bigwedge_{b \in
% [2k]} [(\exists \lambda \, \, \FA{supp}^{c(i, p+1)}_b(g, \delta_{p+1},
% \lambda)) \implies [[(\bigwedge_{a \in [p]} \bigwedge_{d \in [2k]} [(\exists
% \lambda_1 \FA{supp}^{c(i, j)}_d(g, \delta_{a}, \lambda_1)) \implies \\ &
% \vec{z}_{p+1}(b) \neq \vec{z}_{a}(d)]) \land \psi_{R_i, p+1}(\mu, \vec{x},
% \delta_{p+1}, \vec{z}_{p+1}, \vec{\kappa}_{p+1})] \lor \\ & [\bigvee_{a \in
% [p]} \bigvee_{d \in [2k]} (\exists \lambda_1 \FA{supp}^{c(i, j)}_d(g,
% \delta_{a}, \lambda_1))) \land \vec{z}_{p+1}(b) = \vec{z}_{a}(d) \land
% \vec{\kappa}_{p+1}(b) = \vec{\kappa}_{a}(d))]]]
The purpose of the second line of this formula is to check that the assignment
to the support of $\delta_{p +1}$ and the mapping given by $\vec{\kappa}_{p+1}$
are injections and that the assignments to the supports of $\mu$ and
$\delta_{p+1}$ are compatible. The rest of the formula is intended to handle the
three cases that appear in the definition of $\bar{J}^{g, \eta}$. More formally,
the purpose of the third, fourth, and fifth lines is to check that for every $b
\in [2k]$ if there is some $u$ that is the $b$th element of the support of
$\delta_{p+1}$ then either (i) for every $a \in [p]$ we have $\vec{z}_a(b)
\not\in \vec{z}_{p+1}$ and $\vec{\kappa}_{p+1}$ fixes $u$ if $u$ is in the
support of $\mu$ and otherwise moves $u$ to an appropriate point outside the
support of $\mu$, or (ii) there exists some $a \in [p]$ and $d \in [2k]$ such
that $\vec{z}_{p+1}(b) = \vec{z}_a (d)$, and the permutation encoded by
$\vec{\kappa}_{p+1}$ maps $u$ to the same element that $\vec{\kappa}_{a}$ maps
the $d$th element of the support of $\delta_{p+1}$. We let
\begin{align*}
  \psi_{\bar{J}, R_i} (\mu, \vec{x}, \delta_{1}, \vec{z}_1, \ldots,
  \delta_{r_i}, \vec{z}_{r_i}, \vec{\kappa}_1, \ldots, \vec{\kappa}_{r_i}) :=
  \psi^{r_i}_{\bar{J}, R_i} (\mu, \vec{x}, \delta_{1}, \vec{z}_1, \ldots,
  \delta_{r_i}, \vec{z}_{r_i}, \vec{\kappa}_1, \ldots, \vec{\kappa}_{r_i}).
\end{align*}

We now define $\psi_{J, R_i} (\mu, \vec{x}, \delta_{1}\vec{z}_1, \ldots,
\delta_{r_i}\vec{z}_{r_i}, \nu, \vec{y})$ such that $\mathcal{A} \models
\psi_{J, R_i}[g, \vec{a}, u_1, \vec{c}_1, \ldots, u_{r_i}, \vec{c}_{r_i}, h,
\vec{b} \,]$ if, and only if, $g$ is an internal gate, $h \in H_g$, and $J^{g,
  \alpha^{\vec{a}}_{\vec{\consp}(g)}} ((u_1,
\alpha^{\vec{c}_1}_{\vec{\consp}(u_1)}), \ldots, (u_{r_i},
\alpha^{\vec{c}_{r_i}}_{\vec{\consp}(u_{r_i})})) = (h,
\alpha^{\vec{b}}_{\vec{\consp}(h)})$. This formula is defined as follows
\begin{align*}
  \psi_{J, R_i} (\mu, \vec{x}, \delta_{1}, \vec{z}_1, \ldots,  \delta_{r_i}, \vec{z}_{r_i}, \nu, \vec{y}) := \, & \exists \vec{\kappa}_1, \ldots, \vec{\kappa}_{r_i} [\psi_{\bar{J}, R_i} (\mu, \vec{x}, \delta_1, \vec{z}_{1}, \ldots, \delta_{r_i},\vec{z}_{r_i}, \vec{\kappa}_1, \ldots, \vec{\kappa}_{r_i}) \land \\ &\exists \delta_1', \ldots, \delta_{r_i}' (\phi_{L, R_i}(\mu, \nu, \delta_1', \ldots, \delta_{r_i}') \land \\ & \exists \vec{z}_1', \ldots, \vec{z}_{r_i}' [\bigwedge_{j \in [r_i]} [\FA{move}^{c(i, j)} (g, \delta_j, \delta_j', \vec{\kappa}_j) \land \FA{agree}^{c(i, j)}_L(\mu, \nu, \delta_j', \vec{x}, \vec{y}, \vec{z}_j')\land\\ &  [\bigwedge_{1 \leq a < b \leq 2k} \vec{z}_j'(a) \neq \vec{z}_j'(b) \land \bigwedge_{a \in [2k]} (\forall \lambda \, (\neg \FA{supp}^{c(i, j)}(\mu, \delta', \lambda))) \lor \\ & \bigvee_{b \in [2k]} \FA{supp}^{c(i, j)}_{a} (\mu, \delta', \vec{\kappa}_j(b)) \land \vec{z}_j'(a) = \vec{z}_j (b)))]]]
\end{align*}
The purpose of the first line is to define the functions $\vec{\kappa}_1,
\ldots, \vec{\kappa}_{r_i}$ as per the definition of $\psi_{\bar{J}, R_i}$. The
purpose of the second line and the first part of the third line is to define
$\delta_j'$ for each $j \in [r_i]$ such that $\delta_j'$ is the image of
$\delta_j$ under the action of any permutation extending the function
$\vec{\kappa}_j$. For each $j \in [r_i]$ we have an assignment to support of
$\delta_j'$ given by mapping $\vec{\kappa}_j$ to $\vec{z}_j$. From
Lemma~\ref{lem:bar-J-construction} this set of assignments is pairwise
compatible. Notice that $\vec{\kappa}_j$ contains the support of $\delta_j'$,
but perhaps not in order. The purpose of the second part of the third line and
lines four and five is to re-order each $\vec{z}_j$ so as to match the order of
on support of $\delta_j'$, and then to check if the assignment $\vec{y}$ to
$\nu$ is compatible with these assignments.

We now define $\psi_{M, R_i} (\mu, \vec{x}, \delta_1, \vec{z}_1, \ldots,
\delta_{r_i}, {z}_{r_i}; V)$ such that $\mathcal{A} \models \psi_{M, R_i} [g,
\vec{a}, u_1, \vec{c}_1, \ldots u_{r_i}, \vec{c}_{r_i}; \beta(V)]$ if, and only
if, $M^{g, \alpha^{\vec{a}}_{\vec{\consp}(g)}} (((u_1,
\alpha^{\vec{c}_1}_{\vec{\consp}(u_1)}), \ldots, (u_{r_i},
\alpha^{\vec{c}_{r_i}}_{\vec{\consp}(u_{r_i})})), R_i) = 1$, where $\beta(V)$ is
an assignment to $V$ such that for all $h \in H_g$ and $\vec{b} \in A^k$, $(h,
\vec{b}) \in \beta(V)$ if, and only if, $\vec{b} \in \overline{\EV}_h$. This
formula is defined as follows
\begin{align*}
  \psi_{M, R_i}(\mu, \vec{x}, \delta_1, \vec{z}_1, \ldots,  \delta_{r_i}, \vec{z}_{r_i} ; V) := \exists \nu , \vec{y} \, (\psi_{J, R_i}(\mu, \vec{z},  \delta_1, \vec{z}_1, \ldots,  \delta_{r_i}\vec{z}_{r_i}, \nu, \vec{y}) \land V(\nu, \vec{y})).
\end{align*}

We now define a formula $\psi^{D}_j (\mu, \vec{x}, \delta, \vec{z})$ for each $j
\in [l]$ such that $\mathcal{A} \models \psi^{D}_j[g, \vec{a}, u, \vec{c}]$ if,
and only if, $(u, \alpha^{\vec{c}}_{\vec{\consp}(u)}) \in I^{g,
  \alpha^{\vec{a}}_{\vec{\consp}(g)}}_j$. For each $j \in [l]$ we define this
formula as follows
\begin{align*}
  \psi^{D}_j (\mu, \vec{x}, \delta, \vec{z}) := \FA{min-orbit}^j (\mu, \delta) \land \FA{agree}^j_L (\mu, \delta, \vec{x}, \vec{z}).
\end{align*}

We now define a formula $\psi^{\approx}_j(\mu, \vec{x}, \delta_1, \vec{z}_1,
\delta_2, \vec{z}_2)$ for each $j \in [l]$ such that $\mathcal{A} \models
\psi^{\approx}_j [g, \vec{a}, u_1, \vec{c}_1, u_2, \vec{c}_2]$ if, and only if,
$g$ is a gate, $u_1$ and $u_2$ are in the $j$th sort of the vocabulary of $g$,
and $(u_1, \alpha^{\vec{c}_1}_{\vec{\consp}(u_1)}) \equiv (u_2,
\alpha^{\vec{c}_2}_{\vec{\consp}(u_2)})$. For each $j \in [l]$ we define this
formula as follows
\begin{align*}
  \psi^{\approx}_j (\mu, \vec{x}, \delta_1, \vec{z}_1, \delta_2, \vec{z}_2) := & \bigwedge_{1 \leq a < b \leq k}(x_a \neq x_b) \land \bigwedge_{1 \leq a < b \leq 2k}(\vec{z}_1(a) \neq \vec{z}_1(b) \land \vec{z}_2(a) \neq \vec{z}_2(b))  \land  \\ & \FA{agree}^j_L(\mu, \delta_1, \vec{x}, \vec{z}_1) \land \FA{agree}^j_L(\mu, \delta_2, \vec{x}, \vec{z}_2) \land \delta_1 = \delta_2  \land \\ & \exists \vec{\kappa}. \, [(\bigwedge_{1 \leq a < b \leq 2k}\kappa_a \neq \kappa_b) \land \FA{move}^{j}(\mu, \delta_1, \delta_1, \vec{\kappa}) \land \\ & \bigwedge_{a \in [2k]}[(\exists \lambda. \FA{supp}^j_a(\mu, \delta_1, \lambda) \implies  [(\FA{supp}(\mu, \kappa_a) \implies  \FA{supp}^j_a(\mu, \delta_1, \kappa_a)) \land \\ &\bigvee_{b \in [2k]} \FA{supp}^j_b(\mu, \delta_1, \kappa_a) \land \vec{z}_1 (a) = \vec{z}_2(b))]]]
\end{align*}
The purpose of the first line is to check that the assignments to the supports
of $\mu$, $\delta_1$, and $\delta_2$ are injections. The purpose of the second
line is to check that the assignments to $\delta_1$ and $\delta_2$ are
compatible with the assignment to $\mu$ and that $\delta_1 = \delta_2$. The
purpose of the third line is check if there exists a permutation $\sigma$
extending the function encoded by $\vec{\kappa}$ that fixes $\delta_1$. The
purpose of the fourth and fifth line is to check that $\sigma$ also fixes those
elements in the support of $\mu$, fixes the support of $\delta_1$ setwise, and
that applying $\sigma$ maps the assignments $\vec{z}_1$ and $\vec{z}_2$
appropriately. We define $\theta_{\setop_f}$ as follows
\begin{align*}
  \theta_{\setop_f} (\mu, \vec{x} ; V) := \,& (\bigwedge_{1 \leq i < j \leq k} x_i \neq x_j) \land (\exists \pi_1, \ldots, \pi_{m_i}, \kappa \, (\phi_{\setop_f}(\mu, \pi_1, \ldots, \pi_{m_f}, \kappa) \land \\ &(\setop_f [\pi_1, \ldots, \pi_{m_f}][\vec{\psi}^{D}, \vec{\psi}^{\approx}] [(\vec{y}_1 \delta_1, \ldots, \vec{y}_{r_i} \delta_{r_i}) \cdot \psi_{M, R_i} (\mu, \vec{x}, \vec{y}_1, \delta_1, \ldots, \vec{y}_{r_i}, \delta_{r_i}; V)]_{i \in [r]} = \kappa))).
\end{align*}

We now show that $\theta_{\setop_f}$ suffices for this recursive definition.
\begin{lem}
  Let $g$ be a gate such that $\Sigma_n (g) \in \setop_f$ and let $\vec{a} \in
  A^{\underline{[k]}}$. Let $\beta$ be an assignment that maps $\mu$ to $g$,
  $\vec{x}$ to $\vec{a}$, and $V$ to $\beta(V)$ such that for all $h \in H_g$
  and all $\vec{b} \in A^{\underline{[k]}}$ we have $(h, \vec{b}) \in \beta(V)$
  if, and only if , $\vec{b} \in \overline{\EV}_h$. Then $\mathcal{A} \models
  \theta_{\setop_f}[\beta]$ if, and only if, $\vec{a} \in \overline{\EV}_g$.
  \label{lem:inductive-EV-def}
\end{lem}
\begin{proof}
  Let $\eta := \alpha^{\vec{a}}_{\vec{\consp}(g)}$. We define a $\tau$-structure
  $\mathcal{B}$ as follows. For each $i \in [l]$ let $B_i :=
  \quot{(\psi^D_i)^{(\mathcal{A}, \beta)}}{(\psi^{\approx}_i)^{(\mathcal{A},
      \beta)}}$. For each $R_i \in R$ let $R^{\mathcal{B}}_i$ the quotient of
  $(\psi_{M, R_i})^{(\mathcal{A}, \beta)}$ by the equivalence relation $\approx
  := \uplus_{j \in [l]}(\psi^{\approx}_j)^{(\mathcal{A}, \beta)}$. Let
  $\mathcal{B} := (B_1, \ldots, B_l ; R^{\mathcal{B}}_1, \ldots,
  R^{\mathcal{B}}_r)$. Then $\mathcal{B} = \mathcal{I}(\mathcal{A}, \beta)$. We
  now show that $\mathcal{B}$ is isomorphic to $M^{g, \eta}_{\equiv}$. For each
  $i \in [l]$ let $K_i : I^{g, \eta}_{\equiv, i} \ra B_i$ be defined for all
  $[(d, \alpha)] \in I^{g, \eta}_{\equiv, i}$ by $K_i([(d, \alpha)]) := [(d,
  \vec{e})]$, where $\vec{e} \in A^{2k}$ such that
  $\alpha^{\vec{e}}_{\vec{\consp}(d)} = \alpha$ and for all $j, m \in [2k]$ if
  $j \neq m$ then $e_j \neq e_m$. Let $K = \uplus_{i \in [l]}K_i$. It is easy to
  show that $K$ is well-defined and a bijection. Let $R_i \in R$ and let $([d_1,
  \alpha_1], \ldots, [d_{r_i}, \alpha_{r_i}]) \in I^{g, \eta}_{\equiv}$. Then
  $M^{g, \eta}_{\equiv} (([d_1, \alpha_1], \ldots, [d_{r_i}, \alpha_{r_i}]),
  R_i) = 1$ if, and only if, $\mathcal{A} \models \psi_{M, R_i}[g, \vec{a}, d_1,
  \vec{e}_1, \ldots, d_{r_i}, \vec{e}_{r, i}; \beta (V)]$, where for all $j \in
  [r_i]$, $\vec{e}_j \in A^k$ such that $[(d_j, \vec{e}_j)] = K([(d_j,
  \alpha_j)])$ if, and only if, $((K([d_1, \alpha_1]), \ldots, K([d_{r_i},
  \alpha_{r_i}]))) \in R^{\mathcal{B}}_i$. It follows that $K$ is an
  isomorphism.

  Let $p_1, \ldots, p_m, c_1, \ldots, c_l, k_1 \in \nats$ and be such that
  $F^{k_1}_{\setop_f, (p_1, \ldots, p_{m})}[c_1, \ldots, c_l] = \Sigma_n(g)$.
  Let $\gamma \in [n]^{\underline{A}}$ be such that $\gamma^{-1} \sim \eta$. Let
  $E$ be the evaluation function for $\setop_f$ and let $\vec{p} = (p_1, \ldots,
  p_m)$. It follows that
  \begin{align*}
    \mathcal{A} \models \theta_{\setop_f}[\beta] & \iff E(\vec{p}, I(\mathcal{A}, \beta)) = k_1\\ & \iff F^{k_1}_{\setop_f, \vec{p}}[c_1, \ldots, c_l] (\mathcal{B}) \\ &\iff \Sigma_n(g) (\mathcal{B}) = 1\\ & \iff \Sigma_n(g)(M^{g, \eta}_{\equiv}) = 1 \\ & \iff \Sigma_n(g)(L^{\gamma \mathcal{A}}(g)) = 1 \\ & \iff \eta \in \EV_g \\ & \iff \vec{a} \in \overline{\EV}_g.
  \end{align*}
  The fourth equivalence follows from the fact that $\mathcal{B}$ and $M^{g,
    \eta}_\equiv$ are isomorphic and the fifth equivalence follows from the fact
  that $M^{g, \eta}_{\equiv}$ is isomorphic to $L^{\gamma \mathcal{A}}(g)$ (see
  Proposition~\ref{prop:M-to-L-isomorphism}).
  
\end{proof}

We now define $\theta(\mu, \vec{x})$ as follows
\begin{align*}
  \theta (\mu, \vec{x}) := [\ifp_{V,\nu \vec{y}} \bigvee_{s \in T} (\phi_s(\mu) \land \theta_s (\nu, \vec{y} ))] (\mu, \vec{x}).
\end{align*}

Let $g$ be a gate and $\vec{a} \in A^k$. Let $\beta$ be an assignments to $V$
such that for all $h \in H_g$ and all $\vec{b} \in A^{\underline{[k]}}$ we have
$(h, \vec{b}) \in \beta(V)$ if, and only if , $\vec{b} \in \overline{\EV}_h$. It
is easy to show that for each $s \in T \setminus \setop$, $\mathcal{A} \models
\theta_s[g, \vec{a}; \beta(V)]$ if, and only if, $\vec{a} \in \overline{\EV}_g$.
It thus follows from Lemma~\ref{lem:inductive-EV-def} that for all $s \in T$,
$\theta_s[g, \vec{a}; \beta(V)]$ if, and only if, $\vec{a} \in
\overline{\EV}_g$. From this it can be shown, using a straight-forward inductive
argument, that for all $g \in G$ and $\vec{a} \in A^k$, $\mathcal{A} \models
\theta[g, \vec{a}]$ if, and only if, $\vec{a} \in \overline{\EV}_g$.

We now define a $\exFP{\setop}$-formula $Q$ that defines the $q$-ary query
computed by $\mathcal{C}$. The definition of this formula is similar to one
given in~\cite{AndersonD17}. Let
\begin{align*}
  Q (y_1, \ldots y_q) := & \exists \vec{x} \, \exists \mu, \kappa_1 , \ldots  \kappa_q \pi_1 , \ldots , \pi_k \, [\theta (\mu, \vec{x}) \land \phi_\Omega (\kappa_1, \ldots \kappa_q, \mu) \land \\
                         & \bigwedge_{1 \leq i \leq k} (\FA{supp}_i (\mu, \pi_i) \lor \forall \pi \, (\neg \FA{supp}_i (\mu, \pi))) \land \\
                         & \bigwedge_{1 \leq i \leq k} \bigwedge_{1 \leq j \leq q}((\FA{supp}_i (\mu, \pi_i) \land (x_i = y_j)) \implies \kappa_j = \pi_i) \land \\ &                                                                                                                                                        \bigwedge_{1 \leq j \leq q} \bigvee_{1 \leq i \leq k} (x_i = y_j \land \FA{supp}_i (\mu, \pi_i))].
\end{align*}
We could informally understand the formula $Q$ as inverting the assignment
denoted by $(y_1, \ldots, y_q)$, selecting the corresponding output gate, and
then evaluating this output gate. This completes the proof of
Proposition~\ref{prop:translate-circuits-to-formulas}.
\end{document} 